diff -Naur linux.org/drivers/net/usb/ax88179_178a.c linux.new/drivers/net/usb/ax88179_178a.c
--- linux.org/drivers/net/usb/ax88179_178a.c	2019-07-30 15:37:58.000000000 +0200
+++ linux.new/drivers/net/usb/ax88179_178a.c	2020-02-05 13:32:55.527214261 +0100
@@ -1,277 +1,216 @@
-/*
- * ASIX AX88179/178A USB 3.0/2.0 to Gigabit Ethernet Devices
- *
- * Copyright (C) 2011-2013 ASIX
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, see <http://www.gnu.org/licenses/>.
- */
-
+#include <linux/signal.h>
+#include <linux/slab.h>
 #include <linux/module.h>
+#include <linux/netdevice.h>
 #include <linux/etherdevice.h>
 #include <linux/mii.h>
+#include <linux/ethtool.h>
 #include <linux/usb.h>
 #include <linux/crc32.h>
-#include <linux/usb/usbnet.h>
-#include <uapi/linux/mdio.h>
+#include <linux/if_vlan.h>
+#include <linux/uaccess.h>
+#include <linux/list.h>
+#include <linux/ip.h>
+#include <linux/ipv6.h>
+#include <net/ip6_checksum.h>
+#include <linux/usb/cdc.h>
+#include <linux/suspend.h>
+#include <linux/pm_runtime.h>
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/in.h>
 #include <linux/mdio.h>
+#include <uapi/linux/mdio.h>
 
-#define AX88179_PHY_ID				0x03
-#define AX_EEPROM_LEN				0x100
-#define AX88179_EEPROM_MAGIC			0x17900b95
-#define AX_MCAST_FLTSIZE			8
-#define AX_MAX_MCAST				64
-#define AX_INT_PPLS_LINK			((u32)BIT(16))
-#define AX_RXHDR_L4_TYPE_MASK			0x1c
-#define AX_RXHDR_L4_TYPE_UDP			4
-#define AX_RXHDR_L4_TYPE_TCP			16
-#define AX_RXHDR_L3CSUM_ERR			2
-#define AX_RXHDR_L4CSUM_ERR			1
-#define AX_RXHDR_CRC_ERR			((u32)BIT(29))
-#define AX_RXHDR_DROP_ERR			((u32)BIT(31))
-#define AX_ACCESS_MAC				0x01
-#define AX_ACCESS_PHY				0x02
-#define AX_ACCESS_EEPROM			0x04
-#define AX_ACCESS_EFUS				0x05
-#define AX_PAUSE_WATERLVL_HIGH			0x54
-#define AX_PAUSE_WATERLVL_LOW			0x55
-
-#define PHYSICAL_LINK_STATUS			0x02
-	#define	AX_USB_SS		0x04
-	#define	AX_USB_HS		0x02
-
-#define GENERAL_STATUS				0x03
-/* Check AX88179 version. UA1:Bit2 = 0,  UA2:Bit2 = 1 */
-	#define	AX_SECLD		0x04
-
-#define AX_SROM_ADDR				0x07
-#define AX_SROM_CMD				0x0a
-	#define EEP_RD			0x04
-	#define EEP_BUSY		0x10
-
-#define AX_SROM_DATA_LOW			0x08
-#define AX_SROM_DATA_HIGH			0x09
-
-#define AX_RX_CTL				0x0b
-	#define AX_RX_CTL_DROPCRCERR	0x0100
-	#define AX_RX_CTL_IPE		0x0200
-	#define AX_RX_CTL_START		0x0080
-	#define AX_RX_CTL_AP		0x0020
-	#define AX_RX_CTL_AM		0x0010
-	#define AX_RX_CTL_AB		0x0008
-	#define AX_RX_CTL_AMALL		0x0002
-	#define AX_RX_CTL_PRO		0x0001
-	#define AX_RX_CTL_STOP		0x0000
-
-#define AX_NODE_ID				0x10
-#define AX_MULFLTARY				0x16
-
-#define AX_MEDIUM_STATUS_MODE			0x22
-	#define AX_MEDIUM_GIGAMODE	0x01
-	#define AX_MEDIUM_FULL_DUPLEX	0x02
-	#define AX_MEDIUM_EN_125MHZ	0x08
-	#define AX_MEDIUM_RXFLOW_CTRLEN	0x10
-	#define AX_MEDIUM_TXFLOW_CTRLEN	0x20
-	#define AX_MEDIUM_RECEIVE_EN	0x100
-	#define AX_MEDIUM_PS		0x200
-	#define AX_MEDIUM_JUMBO_EN	0x8040
-
-#define AX_MONITOR_MOD				0x24
-	#define AX_MONITOR_MODE_RWLC	0x02
-	#define AX_MONITOR_MODE_RWMP	0x04
-	#define AX_MONITOR_MODE_PMEPOL	0x20
-	#define AX_MONITOR_MODE_PMETYPE	0x40
-
-#define AX_GPIO_CTRL				0x25
-	#define AX_GPIO_CTRL_GPIO3EN	0x80
-	#define AX_GPIO_CTRL_GPIO2EN	0x40
-	#define AX_GPIO_CTRL_GPIO1EN	0x20
-
-#define AX_PHYPWR_RSTCTL			0x26
-	#define AX_PHYPWR_RSTCTL_BZ	0x0010
-	#define AX_PHYPWR_RSTCTL_IPRL	0x0020
-	#define AX_PHYPWR_RSTCTL_AT	0x1000
-
-#define AX_RX_BULKIN_QCTRL			0x2e
-#define AX_CLK_SELECT				0x33
-	#define AX_CLK_SELECT_BCS	0x01
-	#define AX_CLK_SELECT_ACS	0x02
-	#define AX_CLK_SELECT_ULR	0x08
-
-#define AX_RXCOE_CTL				0x34
-	#define AX_RXCOE_IP		0x01
-	#define AX_RXCOE_TCP		0x02
-	#define AX_RXCOE_UDP		0x04
-	#define AX_RXCOE_TCPV6		0x20
-	#define AX_RXCOE_UDPV6		0x40
-
-#define AX_TXCOE_CTL				0x35
-	#define AX_TXCOE_IP		0x01
-	#define AX_TXCOE_TCP		0x02
-	#define AX_TXCOE_UDP		0x04
-	#define AX_TXCOE_TCPV6		0x20
-	#define AX_TXCOE_UDPV6		0x40
-
-#define AX_LEDCTRL				0x73
-
-#define GMII_PHY_PHYSR				0x11
-	#define GMII_PHY_PHYSR_SMASK	0xc000
-	#define GMII_PHY_PHYSR_GIGA	0x8000
-	#define GMII_PHY_PHYSR_100	0x4000
-	#define GMII_PHY_PHYSR_FULL	0x2000
-	#define GMII_PHY_PHYSR_LINK	0x400
-
-#define GMII_LED_ACT				0x1a
-	#define	GMII_LED_ACTIVE_MASK	0xff8f
-	#define	GMII_LED0_ACTIVE	BIT(4)
-	#define	GMII_LED1_ACTIVE	BIT(5)
-	#define	GMII_LED2_ACTIVE	BIT(6)
-
-#define GMII_LED_LINK				0x1c
-	#define	GMII_LED_LINK_MASK	0xf888
-	#define	GMII_LED0_LINK_10	BIT(0)
-	#define	GMII_LED0_LINK_100	BIT(1)
-	#define	GMII_LED0_LINK_1000	BIT(2)
-	#define	GMII_LED1_LINK_10	BIT(4)
-	#define	GMII_LED1_LINK_100	BIT(5)
-	#define	GMII_LED1_LINK_1000	BIT(6)
-	#define	GMII_LED2_LINK_10	BIT(8)
-	#define	GMII_LED2_LINK_100	BIT(9)
-	#define	GMII_LED2_LINK_1000	BIT(10)
-	#define	LED0_ACTIVE		BIT(0)
-	#define	LED0_LINK_10		BIT(1)
-	#define	LED0_LINK_100		BIT(2)
-	#define	LED0_LINK_1000		BIT(3)
-	#define	LED0_FD			BIT(4)
-	#define	LED0_USB3_MASK		0x001f
-	#define	LED1_ACTIVE		BIT(5)
-	#define	LED1_LINK_10		BIT(6)
-	#define	LED1_LINK_100		BIT(7)
-	#define	LED1_LINK_1000		BIT(8)
-	#define	LED1_FD			BIT(9)
-	#define	LED1_USB3_MASK		0x03e0
-	#define	LED2_ACTIVE		BIT(10)
-	#define	LED2_LINK_1000		BIT(13)
-	#define	LED2_LINK_100		BIT(12)
-	#define	LED2_LINK_10		BIT(11)
-	#define	LED2_FD			BIT(14)
-	#define	LED_VALID		BIT(15)
-	#define	LED2_USB3_MASK		0x7c00
-
-#define GMII_PHYPAGE				0x1e
-#define GMII_PHY_PAGE_SELECT			0x1f
-	#define GMII_PHY_PGSEL_EXT	0x0007
-	#define GMII_PHY_PGSEL_PAGE0	0x0000
-	#define GMII_PHY_PGSEL_PAGE3	0x0003
-	#define GMII_PHY_PGSEL_PAGE5	0x0005
-
-struct ax88179_data {
-	u8  eee_enabled;
-	u8  eee_active;
-	u16 rxctl;
-	u16 reserved;
-};
+#include "ax88179_178a.h"
 
-struct ax88179_int_data {
-	__le32 intdata1;
-	__le32 intdata2;
-};
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_LICENSE("GPL");
+MODULE_VERSION(DRIVER_VERSION);
 
-static const struct {
-	unsigned char ctrl, timer_l, timer_h, size, ifg;
-} AX88179_BULKIN_SIZE[] =	{
-	{7, 0x4f, 0,	0x12, 0xff},
-	{7, 0x20, 3,	0x16, 0xff},
-	{7, 0xae, 7,	0x18, 0xff},
-	{7, 0xcc, 0x4c, 0x18, 8},
-};
+/* EEE advertisement is disabled in default setting */
+static int bEEE = 0;
+module_param(bEEE, int, 0);
+MODULE_PARM_DESC(bEEE, "EEE advertisement configuration");
+
+/* Green ethernet advertisement is disabled in default setting */
+static int bGETH = 0;
+module_param(bGETH, int, 0);
+MODULE_PARM_DESC(bGETH, "Green ethernet configuration");
 
-static int __ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			      u16 size, void *data, int in_pm)
+static int
+ax_submit_rx(struct ax_device *dev, struct rx_desc *desc, gfp_t mem_flags);
+
+static inline struct net_device_stats *ax_get_stats(struct net_device *dev)
 {
-	int ret;
-	int (*fn)(struct usbnet *, u8, u8, u16, u16, void *, u16);
+	return &dev->stats;
+}
 
-	BUG_ON(!dev);
+static void ax_set_unplug(struct ax_device *axdev)
+{
+	if (axdev->udev->state == USB_STATE_NOTATTACHED) {
+		set_bit(AX88179_UNPLUG, &axdev->flags);
+		smp_mb__after_atomic();
+	}
+}
 
-	if (!in_pm)
-		fn = usbnet_read_cmd;
-	else
-		fn = usbnet_read_cmd_nopm;
+/*
+ * USB Command
+ */
+static int __ax_usb_read_cmd(struct ax_device *dev, u8 cmd, u8 reqtype,
+			     u16 value, u16 index, void *data, u16 size)
+{
+	void *buf = NULL;
+	int err = -ENOMEM;
+
+	if (size) {
+		buf = kmalloc(size, GFP_KERNEL);
+		if (!buf)
+			goto out;
+	}
+
+	err = usb_control_msg(dev->udev, usb_rcvctrlpipe(dev->udev, 0),
+			      cmd, reqtype, value, index, buf, size,
+			      USB_CTRL_GET_TIMEOUT);
+	if (err > 0 && err <= size) {
+        if (data)
+            memcpy(data, buf, err);
+        else
+            netdev_dbg(dev->netdev,
+                "Huh? Data requested but thrown away.\n");
+    }
+	kfree(buf);
+out:
+	return err;
+}
+
+static int __ax_usb_write_cmd(struct ax_device *dev, u8 cmd, u8 reqtype,
+			      u16 value, u16 index, const void *data,
+			      u16 size)
+{
+	void *buf = NULL;
+	int err = -ENOMEM;
+
+	if (data) {
+		buf = kmemdup(data, size, GFP_KERNEL);
+		if (!buf)
+			goto out;
+	} else {
+		if (size) {
+		    WARN_ON_ONCE(1);
+		    err = -EINVAL;
+		    goto out;
+		}
+   	}
 
-	ret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		 value, index, data, size);
+	err = usb_control_msg(dev->udev, usb_sndctrlpipe(dev->udev, 0),
+			      cmd, reqtype, value, index, buf, size,
+			      USB_CTRL_SET_TIMEOUT);
+	kfree(buf);
 
-	if (unlikely(ret < 0))
-		netdev_warn(dev->net, "Failed to read reg index 0x%04x: %d\n",
-			    index, ret);
+out:
+	return err;
+}
+
+int __ax_read_cmd(struct ax_device *dev, u8 cmd, u8 reqtype,
+		    u16 value, u16 index, void *data, u16 size)
+{
+	int ret;
 
+	if (usb_autopm_get_interface(dev->intf) < 0)
+		return -ENODEV;
+	ret = __ax_usb_read_cmd(dev, cmd, reqtype, value, index,
+				data, size);
+	usb_autopm_put_interface(dev->intf);
 	return ret;
 }
 
-static int __ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			       u16 size, void *data, int in_pm)
+int __ax_write_cmd(struct ax_device *dev, u8 cmd, u8 reqtype,
+		     u16 value, u16 index, const void *data, u16 size)
+{
+	int ret;	
+
+	if (usb_autopm_get_interface(dev->intf) < 0)
+		return -ENODEV;
+	ret = __ax_usb_write_cmd(dev, cmd, reqtype, value, index,
+				 data, size);
+	usb_autopm_put_interface(dev->intf);
+	return ret;
+}
+
+int __ax_read_cmd_nopm(struct ax_device *dev, u8 cmd, u8 reqtype,
+			  u16 value, u16 index, void *data, u16 size)
+{
+	return __ax_usb_read_cmd(dev, cmd, reqtype, value, index,
+				 data, size);
+}
+
+int __ax_write_cmd_nopm(struct ax_device *dev, u8 cmd, u8 reqtype,
+			  u16 value, u16 index, const void *data,
+			  u16 size)
+{
+	return __ax_usb_write_cmd(dev, cmd, reqtype, value, index,
+				  data, size);
+}
+
+static int __ax88179_read_cmd(struct ax_device *dev, u8 cmd, u16 value,
+			      u16 index, u16 size, void *data, int in_pm)
 {
 	int ret;
-	int (*fn)(struct usbnet *, u8, u8, u16, u16, const void *, u16);
 
-	BUG_ON(!dev);
+	int (*fn)(struct ax_device *, u8, u8, u16, u16, void *, u16);
 
 	if (!in_pm)
-		fn = usbnet_write_cmd;
+		fn = __ax_read_cmd;
 	else
-		fn = usbnet_write_cmd_nopm;
+		fn = __ax_read_cmd_nopm;
 
-	ret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE,
-		 value, index, data, size);
+	ret = fn(dev, cmd, USB_DIR_IN | USB_TYPE_VENDOR |
+		 USB_RECIP_DEVICE, value, index, data, size);
 
 	if (unlikely(ret < 0))
-		netdev_warn(dev->net, "Failed to write reg index 0x%04x: %d\n",
-			    index, ret);
-
+		netdev_warn(dev->netdev,
+			    "Failed to read reg cmd 0x%04x, value 0x%04x: %d\n",
+			    cmd, value, ret);
 	return ret;
 }
 
-static void ax88179_write_cmd_async(struct usbnet *dev, u8 cmd, u16 value,
-				    u16 index, u16 size, void *data)
+static int __ax88179_write_cmd(struct ax_device *dev, u8 cmd, u16 value,
+			       u16 index, u16 size, void *data, int in_pm)
 {
-	u16 buf;
+	int ret;
 
-	if (2 == size) {
-		buf = *((u16 *)data);
-		cpu_to_le16s(&buf);
-		usbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
-				       USB_RECIP_DEVICE, value, index, &buf,
-				       size);
-	} else {
-		usbnet_write_cmd_async(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
-				       USB_RECIP_DEVICE, value, index, data,
-				       size);
-	}
+	int (*fn)(struct ax_device *, u8, u8, u16, u16, const void *, u16);
+
+	if (!in_pm)
+		fn = __ax_write_cmd;
+	else
+		fn = __ax_write_cmd_nopm;
+
+	ret = fn(dev, cmd, USB_DIR_OUT | USB_TYPE_VENDOR |
+		 USB_RECIP_DEVICE, value, index, data, size);
+
+	if (unlikely(ret < 0))
+		netdev_warn(dev->netdev,
+			    "Failed to write reg cmd 0x%04x, value 0x%04x: %d\n",
+			    cmd, value, ret);
+
+	return ret;
 }
 
-static int ax88179_read_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
-				 u16 index, u16 size, void *data)
+static int ax88179_read_cmd_nopm(struct ax_device *dev, u8 cmd, u16 value,
+				 u16 index, u16 size, void *data, int eflag)
 {
 	int ret;
 
-	if (2 == size) {
-		u16 buf;
+	if (eflag && (2 == size)) {
+		u16 buf = 0;
 		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);
 		le16_to_cpus(&buf);
 		*((u16 *)data) = buf;
-	} else if (4 == size) {
-		u32 buf;
+	} else if (eflag && (4 == size)) {
+		u32 buf = 0;
 		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 1);
 		le32_to_cpus(&buf);
 		*((u32 *)data) = buf;
@@ -282,13 +221,13 @@
 	return ret;
 }
 
-static int ax88179_write_cmd_nopm(struct usbnet *dev, u8 cmd, u16 value,
+static int ax88179_write_cmd_nopm(struct ax_device *dev, u8 cmd, u16 value,
 				  u16 index, u16 size, void *data)
 {
 	int ret;
 
 	if (2 == size) {
-		u16 buf;
+		u16 buf = 0;
 		buf = *((u16 *)data);
 		cpu_to_le16s(&buf);
 		ret = __ax88179_write_cmd(dev, cmd, value, index,
@@ -301,18 +240,19 @@
 	return ret;
 }
 
-static int ax88179_read_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
-			    u16 size, void *data)
+static int ax88179_read_cmd(struct ax_device *dev, u8 cmd, u16 value, u16 index,
+			    u16 size, void *data, int eflag)
 {
+
 	int ret;
 
-	if (2 == size) {
-		u16 buf;
+	if (eflag && (2 == size)) {
+		u16 buf = 0;
 		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 0);
 		le16_to_cpus(&buf);
 		*((u16 *)data) = buf;
-	} else if (4 == size) {
-		u32 buf;
+	} else if (eflag && (4 == size)) {
+		u32 buf = 0;
 		ret = __ax88179_read_cmd(dev, cmd, value, index, size, &buf, 0);
 		le32_to_cpus(&buf);
 		*((u32 *)data) = buf;
@@ -323,13 +263,13 @@
 	return ret;
 }
 
-static int ax88179_write_cmd(struct usbnet *dev, u8 cmd, u16 value, u16 index,
+static int ax88179_write_cmd(struct ax_device *dev, u8 cmd, u16 value, u16 index,
 			     u16 size, void *data)
 {
 	int ret;
 
 	if (2 == size) {
-		u16 buf;
+		u16 buf = 0;
 		buf = *((u16 *)data);
 		cpu_to_le16s(&buf);
 		ret = __ax88179_write_cmd(dev, cmd, value, index,
@@ -342,605 +282,1455 @@
 	return ret;
 }
 
-static void ax88179_status(struct usbnet *dev, struct urb *urb)
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 20)
+static void ax88179_async_write_callback(struct urb *urb, struct pt_regs *regs)
+#else
+static void ax88179_async_write_callback(struct urb *urb)
+#endif
+{
+	struct ax_device_async_handle *asyncdata =
+				(struct ax_device_async_handle *)urb->context;
+
+	if (urb->status < 0)
+		printk(KERN_ERR "ax88179_async_cmd_callback() failed with %d",
+		       urb->status);
+
+	kfree(asyncdata->req);
+	kfree(asyncdata);	
+	usb_free_urb(urb);
+	
+}
+
+static void
+ax88179_write_cmd_async(struct ax_device *dev, u8 cmd, u16 value, u16 index,
+				    u16 size, void *data)
 {
-	struct ax88179_int_data *event;
-	u32 link;
+	struct usb_ctrlrequest *req = NULL;
+	int status = 0;
+	struct urb *urb = NULL;
+	void *buf = NULL;
+	struct ax_device_async_handle *asyncdata = NULL;
+
+	urb = usb_alloc_urb(0, GFP_ATOMIC);
+	if (urb == NULL) {
+		netdev_err(dev->netdev,
+			   "Error allocating URB in write_cmd_async!");
+		return;
+	}
 
-	if (urb->actual_length < 8)
+	req = kmalloc(sizeof(struct usb_ctrlrequest), GFP_ATOMIC);
+	if (req == NULL) {
+		netdev_err(dev->netdev,
+			   "Failed to allocate memory for control request");
+		usb_free_urb(urb);
 		return;
+	}
 
-	event = urb->transfer_buffer;
-	le32_to_cpus((void *)&event->intdata1);
+	asyncdata = (struct ax_device_async_handle*)
+			kmalloc(sizeof(struct ax_device_async_handle), GFP_ATOMIC);
+	if (asyncdata == NULL) {
+		netdev_err(dev->netdev,
+			   "Failed to allocate memory for async data");
+		kfree(req);
+		usb_free_urb(urb);
+		return;
+	}
 
-	link = (((__force u32)event->intdata1) & AX_INT_PPLS_LINK) >> 16;
+	asyncdata->req = req;
+	
+	if (size == 2) {
+		asyncdata->rxctl = *((u16 *)data);
+		cpu_to_le16s(&asyncdata->rxctl);
+		buf = &asyncdata->rxctl;
+	} else {
+		memcpy(asyncdata->m_filter, data, size);
+		buf = asyncdata->m_filter;
+	}
 
-	if (netif_carrier_ok(dev->net) != link) {
-		usbnet_link_change(dev, link, 1);
-		netdev_info(dev->net, "ax88179 - Link status is: %d\n", link);
+	req->bRequestType = USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE;
+	req->bRequest = cmd;
+	req->wValue = cpu_to_le16(value);
+	req->wIndex = cpu_to_le16(index);
+	req->wLength = cpu_to_le16(size);
+
+	usb_fill_control_urb(urb, dev->udev,
+			     usb_sndctrlpipe(dev->udev, 0),
+			     (void *)req, buf, size,
+			     ax88179_async_write_callback, asyncdata);
+
+	status = usb_submit_urb(urb, GFP_ATOMIC);
+	if (status < 0) {
+		netdev_err(dev->netdev,
+			   "Error submitting the control message: status=%d",
+			   status);
+		kfree(req);
+		kfree(asyncdata);
+		usb_free_urb(urb);
 	}
 }
 
-static int ax88179_mdio_read(struct net_device *netdev, int phy_id, int loc)
+/*
+ * MDIO Read/Write
+ */
+
+static int ax88179_mdio_read(struct net_device *netdev, int phy_id, int reg)
 {
-	struct usbnet *dev = netdev_priv(netdev);
+	struct ax_device *dev = netdev_priv(netdev);
 	u16 res;
 
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);
+	ax88179_read_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)reg, 2, &res, 1);
+
 	return res;
 }
 
-static void ax88179_mdio_write(struct net_device *netdev, int phy_id, int loc,
-			       int val)
+static
+void ax88179_mdio_write(struct net_device *netdev, int phy_id, int reg, int val)
 {
-	struct usbnet *dev = netdev_priv(netdev);
-	u16 res = (u16) val;
+	struct ax_device *dev = netdev_priv(netdev);
+	u16 res = (u16)val;
 
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)loc, 2, &res);
+	ax88179_write_cmd(dev, AX_ACCESS_PHY, phy_id, (__u16)reg, 2, &res);
 }
 
-static inline int ax88179_phy_mmd_indirect(struct usbnet *dev, u16 prtad,
-					   u16 devad)
+/* End of MDIO Read/Write */
+
+/*
+ * URB callback routine
+ */
+
+static void ax_read_bulk_callback(struct urb *urb)
 {
-	u16 tmp16;
-	int ret;
+	struct net_device *netdev;
+	int status = urb->status;
+	struct rx_desc *desc;
+	struct ax_device *axdev;
 
-	tmp16 = devad;
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_CTRL, 2, &tmp16);
-
-	tmp16 = prtad;
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_DATA, 2, &tmp16);
-
-	tmp16 = devad | MII_MMD_CTRL_NOINCR;
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_CTRL, 2, &tmp16);
+	desc = urb->context;
+	if (!desc)
+		return;
 
-	return ret;
-}
+	axdev = desc->context;
+	if (!axdev)
+		return;
 
-static int
-ax88179_phy_read_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad)
-{
-	int ret;
-	u16 tmp16;
+	if (test_bit(AX88179_UNPLUG, &axdev->flags))
+		return;
 
-	ax88179_phy_mmd_indirect(dev, prtad, devad);
+	if (!test_bit(AX88179_ENABLE, &axdev->flags))
+		return;
 
-	ret = ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			       MII_MMD_DATA, 2, &tmp16);
-	if (ret < 0)
-		return ret;
+	netdev = axdev->netdev;
+
+	if (!netif_carrier_ok(netdev))
+		return;
 
-	return tmp16;
+	usb_mark_last_busy(axdev->udev);
+
+	switch (status) {
+	case 0:
+		if (urb->actual_length < ETH_ZLEN)
+			break;
+
+		spin_lock(&axdev->rx_lock);
+		list_add_tail(&desc->list, &axdev->rx_done);
+		spin_unlock(&axdev->rx_lock);
+		napi_schedule(&axdev->napi);
+		return;
+	case -ESHUTDOWN:
+		ax_set_unplug(axdev);
+		netif_device_detach(axdev->netdev);
+		return;
+	case -ENOENT:
+		return;	/* the urb is in unlink state */
+	case -ETIME:
+		if (net_ratelimit())
+			netif_warn(axdev, rx_err, netdev,
+				   "maybe reset is needed?\n");
+		break;
+	default:
+		if (net_ratelimit())
+			netif_warn(axdev, rx_err, netdev,
+				   "Rx status %d\n", status);
+		break;
+	}
+
+	ax_submit_rx(axdev, desc, GFP_ATOMIC);
 }
 
-static int
-ax88179_phy_write_mmd_indirect(struct usbnet *dev, u16 prtad, u16 devad,
-			       u16 data)
+static void ax_write_bulk_callback(struct urb *urb)
 {
-	int ret;
+	struct net_device_stats *stats;
+	struct net_device *netdev;
+	struct tx_desc *desc;
+	struct ax_device *axdev;
+	int status = urb->status;
 
-	ax88179_phy_mmd_indirect(dev, prtad, devad);
+	desc = urb->context;
+	if (!desc)
+		return;
 
-	ret = ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-				MII_MMD_DATA, 2, &data);
+	axdev = desc->context;
+	if (!axdev)
+		return;
 
-	if (ret < 0)
-		return ret;
+	netdev = axdev->netdev;
+	stats = ax_get_stats(netdev);
+	if (status) {
+		if (net_ratelimit())
+			netif_warn(axdev, tx_err, netdev,
+				   "Tx status %d\n", status);
+		stats->tx_errors += desc->skb_num;
+	} else {
+		stats->tx_packets += desc->skb_num;
+		stats->tx_bytes += desc->skb_len;
+	}
 
-	return 0;
+	spin_lock(&axdev->tx_lock);
+	list_add_tail(&desc->list, &axdev->tx_free);
+	spin_unlock(&axdev->tx_lock);
+
+	usb_autopm_put_interface_async(axdev->intf);
+
+	if (!netif_carrier_ok(netdev))
+		return;
+
+	if (!test_bit(AX88179_ENABLE, &axdev->flags))
+		return;
+
+	if (test_bit(AX88179_UNPLUG, &axdev->flags))
+		return;
+
+	if (!skb_queue_empty(&axdev->tx_queue))
+		napi_schedule(&axdev->napi);
 }
 
-static int ax88179_suspend(struct usb_interface *intf, pm_message_t message)
+static void ax_intr_callback(struct urb *urb)
 {
-	struct usbnet *dev = usb_get_intfdata(intf);
-	u16 tmp16;
-	u8 tmp8;
-
-	usbnet_suspend(intf, message);
-
-	/* Disable RX path */
-	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			      2, 2, &tmp16);
-	tmp16 &= ~AX_MEDIUM_RECEIVE_EN;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			       2, 2, &tmp16);
+	struct ax_device *axdev;
+	struct ax_device_int_data *event = NULL;
+	int status = urb->status;
+	int res;
 
-	/* Force bulk-in zero length */
-	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			      2, 2, &tmp16);
-
-	tmp16 |= AX_PHYPWR_RSTCTL_BZ | AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			       2, 2, &tmp16);
-
-	/* change clock */
-	tmp8 = 0;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
+	axdev = urb->context;
+	if (!axdev)
+		return;
 
-	/* Configure RX control register => stop operation */
-	tmp16 = AX_RX_CTL_STOP;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);
+	if (!test_bit(AX88179_ENABLE, &axdev->flags)) 
+		return;
 
-	return 0;
-}
+	if (test_bit(AX88179_UNPLUG, &axdev->flags)) 
+		return;
+
+	switch (status) {
+	case 0:			/* success */
+		break;
+	case -ECONNRESET:	/* unlink */
+	case -ESHUTDOWN:
+		netif_device_detach(axdev->netdev);
+	case -ENOENT:
+	case -EPROTO:
+		netif_info(axdev, intr, axdev->netdev,
+			   "Stop submitting intr, status %d\n", status);
+		return;
+	case -EOVERFLOW:
+		netif_info(axdev, intr, axdev->netdev,
+			   "intr status -EOVERFLOW\n");
+		goto resubmit;
+	/* -EPIPE:  should clear the halt */
+	default:
+		netif_info(axdev, intr, axdev->netdev,
+			   "intr status %d\n", status);
+		goto resubmit;
+	}
+	
+	event = urb->transfer_buffer;
+	axdev->link = event->link & AX_INT_PPLS_LINK;
 
-/* This function is used to enable the autodetach function. */
-/* This function is determined by offset 0x43 of EEPROM */
-static int ax88179_auto_detach(struct usbnet *dev, int in_pm)
-{
-	u16 tmp16;
-	u8 tmp8;
-	int (*fnr)(struct usbnet *, u8, u16, u16, u16, void *);
-	int (*fnw)(struct usbnet *, u8, u16, u16, u16, void *);
-
-	if (!in_pm) {
-		fnr = ax88179_read_cmd;
-		fnw = ax88179_write_cmd;
+	if (axdev->link) {
+		if (!netif_carrier_ok(axdev->netdev)) { //Link up
+			set_bit(AX88179_LINK_CHG, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		}
 	} else {
-		fnr = ax88179_read_cmd_nopm;
-		fnw = ax88179_write_cmd_nopm;
+		if (netif_carrier_ok(axdev->netdev)) { //Link down
+			netif_stop_queue(axdev->netdev);
+			set_bit(AX88179_LINK_CHG, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		}
 	}
 
-	if (fnr(dev, AX_ACCESS_EEPROM, 0x43, 1, 2, &tmp16) < 0)
-		return 0;
+resubmit:
+	res = usb_submit_urb(urb, GFP_ATOMIC);
+	if (res == -ENODEV) {
+		ax_set_unplug(axdev);
+		netif_device_detach(axdev->netdev);
+	} else if (res) {
+		netif_err(axdev, intr, axdev->netdev,
+			  "can't resubmit intr, status %d\n", res);
+	}
+}
 
-	if ((tmp16 == 0xFFFF) || (!(tmp16 & 0x0100)))
-		return 0;
+/* End of URB callback routine */
 
-	/* Enable Auto Detach bit */
-	tmp8 = 0;
-	fnr(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-	tmp8 |= AX_CLK_SELECT_ULR;
-	fnw(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-
-	fnr(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);
-	tmp16 |= AX_PHYPWR_RSTCTL_AT;
-	fnw(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);
+/*
+ * Allocate TX/RX memory
+ */ 
 
-	return 0;
+static inline void *__rx_buf_align(void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, RX_ALIGN);
 }
 
-static int ax88179_resume(struct usb_interface *intf)
+static inline void *__tx_buf_align(void *data)
+{
+	return (void *)ALIGN((uintptr_t)data, TX_ALIGN);
+}
+
+static void ax_free_buffer(struct ax_device *axdev)
 {
-	struct usbnet *dev = usb_get_intfdata(intf);
-	u16 tmp16;
-	u8 tmp8;
+	int i;
 
-	usbnet_link_change(dev, 0, 0);
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		usb_free_urb(axdev->rx_list[i].urb);
+		axdev->rx_list[i].urb = NULL;
 
-	/* Power up ethernet PHY */
-	tmp16 = 0;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			       2, 2, &tmp16);
-	udelay(1000);
-
-	tmp16 = AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
-			       2, 2, &tmp16);
-	msleep(200);
+		kfree(axdev->rx_list[i].buffer);
+		axdev->rx_list[i].buffer = NULL;
+		axdev->rx_list[i].head = NULL;
+	}
 
-	/* Ethernet PHY Auto Detach*/
-	ax88179_auto_detach(dev, 1);
+	for (i = 0; i < AX88179_MAX_TX; i++) {
+		usb_free_urb(axdev->tx_list[i].urb);
+		axdev->tx_list[i].urb = NULL;
 
-	/* Enable clock */
-	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC,  AX_CLK_SELECT, 1, 1, &tmp8);
-	tmp8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp8);
-	msleep(100);
+		kfree(axdev->tx_list[i].buffer);
+		axdev->tx_list[i].buffer = NULL;
+		axdev->tx_list[i].head = NULL;
+	}
 
-	/* Configure RX control register => start operation */
-	tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |
-		AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
-	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);
+	usb_free_urb(axdev->intr_urb);
+	axdev->intr_urb = NULL;
 
-	return usbnet_resume(intf);
+	kfree(axdev->intr_buff);
+	axdev->intr_buff = NULL;
 }
 
-static void
-ax88179_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+static int ax_alloc_buffer(struct ax_device *axdev)
 {
-	struct usbnet *dev = netdev_priv(net);
-	u8 opt;
+	struct net_device *netdev = axdev->netdev;
+	struct usb_interface *intf = axdev->intf;
+	struct usb_host_interface *alt = intf->cur_altsetting;
+	struct usb_host_endpoint *ep_intr = alt->endpoint;
+	struct urb *urb;
+	int node, i;
+	u8 *buf;
 
-	if (ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,
-			     1, 1, &opt) < 0) {
-		wolinfo->supported = 0;
-		wolinfo->wolopts = 0;
-		return;
-	}
+	node = netdev->dev.parent ? dev_to_node(netdev->dev.parent) : -1;
 
-	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
-	wolinfo->wolopts = 0;
-	if (opt & AX_MONITOR_MODE_RWLC)
-		wolinfo->wolopts |= WAKE_PHY;
-	if (opt & AX_MONITOR_MODE_RWMP)
-		wolinfo->wolopts |= WAKE_MAGIC;
-}
+	spin_lock_init(&axdev->rx_lock);
+	spin_lock_init(&axdev->tx_lock);
+	INIT_LIST_HEAD(&axdev->tx_free);
+	INIT_LIST_HEAD(&axdev->rx_done);
+	skb_queue_head_init(&axdev->tx_queue);
+	skb_queue_head_init(&axdev->rx_queue);
+	skb_queue_head_init(&axdev->tx_lso_done);
 
-static int
-ax88179_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u8 opt = 0;
+	/* RX */
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		buf = kmalloc_node(AX88179_BUF_RX_SIZE, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
 
-	if (wolinfo->wolopts & ~(WAKE_PHY | WAKE_MAGIC))
-		return -EINVAL;
+		if (buf != __rx_buf_align(buf)) {
+			kfree(buf);
+			buf = kmalloc_node(AX88179_BUF_RX_SIZE + RX_ALIGN,
+					   GFP_KERNEL, node);
+			if (!buf)
+				goto err1;
+		}
 
-	if (wolinfo->wolopts & WAKE_PHY)
-		opt |= AX_MONITOR_MODE_RWLC;
-	if (wolinfo->wolopts & WAKE_MAGIC)
-		opt |= AX_MONITOR_MODE_RWMP;
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
 
-	if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD,
-			      1, 1, &opt) < 0)
-		return -EINVAL;
+		INIT_LIST_HEAD(&axdev->rx_list[i].list);
+		axdev->rx_list[i].context = axdev;
+		axdev->rx_list[i].urb = urb;
+		axdev->rx_list[i].buffer = buf;
+		axdev->rx_list[i].head = __rx_buf_align(buf);
+	}
+	/* TX */
+	for (i = 0; i < AX88179_MAX_TX; i++) {
+		buf = kmalloc_node(AX88179_BUF_TX_SIZE, GFP_KERNEL, node);
+		if (!buf)
+			goto err1;
+
+		if (buf != __tx_buf_align(buf)) {
+			kfree(buf);
+			buf = kmalloc_node(AX88179_BUF_TX_SIZE + TX_ALIGN,
+					   GFP_KERNEL, node);
+			if (!buf)
+				goto err1;
+		}
+
+		urb = usb_alloc_urb(0, GFP_KERNEL);
+		if (!urb) {
+			kfree(buf);
+			goto err1;
+		}
+
+		INIT_LIST_HEAD(&axdev->tx_list[i].list);
+		axdev->tx_list[i].context = axdev;
+		axdev->tx_list[i].urb = urb;
+		axdev->tx_list[i].buffer = buf;
+		axdev->tx_list[i].head = __tx_buf_align(buf);
+
+		list_add_tail(&axdev->tx_list[i].list, &axdev->tx_free);
+	}
+	/* Interrupt */
+	axdev->intr_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (!axdev->intr_urb)
+		goto err1;
+
+	axdev->intr_buff = kmalloc(INTBUFSIZE, GFP_KERNEL);
+	if (!axdev->intr_buff)
+		goto err1;
+
+	axdev->intr_interval = (int)ep_intr->desc.bInterval;
+	usb_fill_int_urb(axdev->intr_urb, axdev->udev,
+			 usb_rcvintpipe(axdev->udev, 1), axdev->intr_buff,
+			 INTBUFSIZE, ax_intr_callback, axdev,
+			 axdev->intr_interval);
 
 	return 0;
+
+err1:
+	ax_free_buffer(axdev);
+	return -ENOMEM;
 }
+/* End of Allocate TX/RX memory */
+
+/*
+ * TX/RX operations
+ */
 
-static int ax88179_get_eeprom_len(struct net_device *net)
+static void ax_lso_complete (struct urb *urb)
 {
-	return AX_EEPROM_LEN;
+	struct sk_buff		*skb = (struct sk_buff *) urb->context;
+	struct skb_data		*entry = (struct skb_data *) skb->cb;
+	struct ax_device 		*dev = entry->dev;
+
+	if (urb->status == 0) {
+		dev->netdev->stats.tx_packets++;
+		dev->netdev->stats.tx_bytes += entry->length;
+	} else {
+		dev->netdev->stats.tx_errors++;
+	}
+
+	usb_autopm_put_interface_async(dev->intf);
+	skb_queue_tail(&dev->tx_lso_done, skb);
 }
 
-static int
-ax88179_get_eeprom(struct net_device *net, struct ethtool_eeprom *eeprom,
-		   u8 *data)
+static struct sk_buff *
+ax_tx_fixup(struct ax_device *dev, struct sk_buff *skb, gfp_t flags)
 {
-	struct usbnet *dev = netdev_priv(net);
-	u16 *eeprom_buff;
-	int first_word, last_word;
-	int i, ret;
+	u32 tx_hdr1 = 0, tx_hdr2 = 0;
+	int headroom = 0, tailroom = 0;
 
-	if (eeprom->len == 0)
-		return -EINVAL;
+	tx_hdr1 = skb->len;
+	tx_hdr2 = skb_shinfo(skb)->gso_size;
 
-	eeprom->magic = AX88179_EEPROM_MAGIC;
+	if ((dev->netdev->features & NETIF_F_SG) && skb_linearize(skb))
+		return NULL;
 
-	first_word = eeprom->offset >> 1;
-	last_word = (eeprom->offset + eeprom->len - 1) >> 1;
-	eeprom_buff = kmalloc(sizeof(u16) * (last_word - first_word + 1),
-			      GFP_KERNEL);
-	if (!eeprom_buff)
-		return -ENOMEM;
+	headroom = skb_headroom(skb);
+	tailroom = skb_tailroom(skb);
 
-	/* ax88179/178A returns 2 bytes from eeprom on read */
-	for (i = first_word; i <= last_word; i++) {
-		ret = __ax88179_read_cmd(dev, AX_ACCESS_EEPROM, i, 1, 2,
-					 &eeprom_buff[i - first_word],
-					 0);
-		if (ret < 0) {
-			kfree(eeprom_buff);
-			return -EIO;
+	if ((headroom + tailroom) >= 8) {
+		if (headroom < 8) {
+			skb->data = memmove(skb->head + 8, skb->data, skb->len);
+			skb_set_tail_pointer(skb, skb->len);
 		}
+	} else {
+		struct sk_buff *skb2 = NULL;
+		skb2 = skb_copy_expand(skb, 8, 0, flags);
+		dev_kfree_skb_any(skb);
+		skb = skb2;
+		if (!skb)
+			return NULL;
 	}
 
-	memcpy(data, (u8 *)eeprom_buff + (eeprom->offset & 1), eeprom->len);
-	kfree(eeprom_buff);
-	return 0;
+	skb_push(skb, 4);
+	cpu_to_le32s(&tx_hdr2);
+	skb_copy_to_linear_data(skb, &tx_hdr2, 4);
+
+	skb_push(skb, 4);
+	cpu_to_le32s(&tx_hdr1);
+	skb_copy_to_linear_data(skb, &tx_hdr1, 4);
+
+	return skb;
+
 }
 
-static int ax88179_get_link_ksettings(struct net_device *net,
-				      struct ethtool_link_ksettings *cmd)
+static int ax_lso_xmit (struct sk_buff *skb, struct net_device *net)
 {
-	struct usbnet *dev = netdev_priv(net);
+	struct ax_device *axdev = netdev_priv(net);
+	struct net_device_stats *stats;
+	struct urb *urb = NULL;
+	struct skb_data	*entry;
+	int ret, length;	
+	
+	skb = ax_tx_fixup(axdev, skb, GFP_ATOMIC);	
+	if (!skb)
+		goto drop;
+
+	length = skb->len;
+
+	if (!(urb = usb_alloc_urb (0, GFP_ATOMIC))) {
+		netif_dbg(axdev, tx_err, axdev->netdev, "no urb\n");
+		goto drop;
+	}
+
+	entry = (struct skb_data *) skb->cb;
+	entry->urb = urb;
+	entry->dev = axdev;
+	entry->length = length;
 
-	mii_ethtool_get_link_ksettings(&dev->mii, cmd);
+	ret = usb_autopm_get_interface_async(axdev->intf);
+	if (ret < 0)
+		goto drop;
 
-	return 0;
+	usb_fill_bulk_urb (urb, axdev->udev, usb_sndbulkpipe(axdev->udev, 3),
+			skb->data, skb->len, ax_lso_complete, skb);	
+
+	ret = usb_submit_urb(urb, GFP_ATOMIC);
+	if (ret < 0)
+		usb_autopm_put_interface_async(axdev->intf);
+
+	if (ret) {		
+drop:
+		stats = ax_get_stats(axdev->netdev);
+		stats->tx_dropped++;
+		if (skb)
+			dev_kfree_skb_any (skb);
+		if (urb)
+			usb_free_urb (urb);
+	} else
+		netif_dbg(axdev, tx_queued, axdev->netdev,
+			  "> tx, len %d, type 0x%x\n", length, skb->protocol);
+
+	return ret;
 }
 
-static int ax88179_set_link_ksettings(struct net_device *net,
-				      const struct ethtool_link_ksettings *cmd)
+static struct tx_desc *ax_get_tx_desc(struct ax_device *dev)
 {
-	struct usbnet *dev = netdev_priv(net);
-	return mii_ethtool_set_link_ksettings(&dev->mii, cmd);
+	struct tx_desc *desc = NULL;
+	unsigned long flags;
+
+	if (list_empty(&dev->tx_free))
+		return NULL;
+
+	spin_lock_irqsave(&dev->tx_lock, flags);
+	if (!list_empty(&dev->tx_free)) {
+		struct list_head *cursor;
+
+		cursor = dev->tx_free.next;
+		list_del_init(cursor);
+		desc = list_entry(cursor, struct tx_desc, list);
+	}
+	spin_unlock_irqrestore(&dev->tx_lock, flags);
+
+	return desc;
 }
 
-static int
-ax88179_ethtool_get_eee(struct usbnet *dev, struct ethtool_eee *data)
+static int ax_tx_desc_fill(struct ax_device *axdev, struct tx_desc *desc)
 {
-	int val;
+	struct sk_buff_head skb_head, *tx_queue = &axdev->tx_queue;
+	struct net_device_stats *stats = &axdev->netdev->stats;
+	struct sk_buff *lso_skb = NULL;
+	int remain, ret;
+	u8 *tx_data;
 
-	/* Get Supported EEE */
-	val = ax88179_phy_read_mmd_indirect(dev, MDIO_PCS_EEE_ABLE,
-					    MDIO_MMD_PCS);
-	if (val < 0)
-		return val;
-	data->supported = mmd_eee_cap_to_ethtool_sup_t(val);
-
-	/* Get advertisement EEE */
-	val = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_ADV,
-					    MDIO_MMD_AN);
-	if (val < 0)
-		return val;
-	data->advertised = mmd_eee_adv_to_ethtool_adv_t(val);
-
-	/* Get LP advertisement EEE */
-	val = ax88179_phy_read_mmd_indirect(dev, MDIO_AN_EEE_LPABLE,
-					    MDIO_MMD_AN);
-	if (val < 0)
-		return val;
-	data->lp_advertised = mmd_eee_adv_to_ethtool_adv_t(val);
+	__skb_queue_head_init(&skb_head);
+	spin_lock(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock(&tx_queue->lock);
 
-	return 0;
+	tx_data = desc->head;
+	desc->skb_num = 0;
+	desc->skb_len = 0;
+	remain = AX88179_BUF_TX_SIZE;
+
+	while (remain >= ETH_ZLEN + 8) {
+		struct sk_buff *skb;
+		u32 *tx_hdr;
+
+		skb = __skb_dequeue(&skb_head);
+		if (!skb)
+			break;
+
+		if (skb_shinfo(skb)->gso_size > 0) {
+			lso_skb = skb;
+			break;
+		}
+
+		if ((skb->len + AX_TX_HEADER_LEN) > remain) {
+			__skb_queue_head(&skb_head, skb);
+			break;
+		}		
+		
+		memset(tx_data, 0, AX_TX_HEADER_LEN);
+		tx_hdr = (u32 *)tx_data;
+		*tx_hdr = skb->len;
+		cpu_to_le32s(*tx_hdr);		
+		tx_data += 8;
+
+		if (skb_copy_bits(skb, 0, tx_data, skb->len) < 0) {
+			stats->tx_dropped++;
+			dev_kfree_skb_any(skb);
+			continue;
+		}
+	
+		tx_data += skb->len;
+		desc->skb_len += skb->len;
+		desc->skb_num++;		
+
+		dev_kfree_skb_any(skb);
+
+		tx_data = __tx_buf_align(tx_data);
+		remain = AX88179_BUF_TX_SIZE - (int)((void *)tx_data - desc->head);
+	}
+
+	if (!skb_queue_empty(&skb_head)) {
+		spin_lock(&tx_queue->lock);
+		skb_queue_splice(&skb_head, tx_queue);
+		spin_unlock(&tx_queue->lock);
+	}
+
+	netif_tx_lock(axdev->netdev);
+
+	if (netif_queue_stopped(axdev->netdev) &&
+	    skb_queue_len(&axdev->tx_queue) < axdev->tx_qlen)
+		netif_wake_queue(axdev->netdev);
+
+	netif_tx_unlock(axdev->netdev);
+
+	ret = usb_autopm_get_interface_async(axdev->intf);
+	if (ret < 0)
+		goto out_tx_fill;
+
+	usb_fill_bulk_urb(desc->urb, axdev->udev, usb_sndbulkpipe(axdev->udev, 3),
+			  desc->head, (int)(tx_data - (u8 *)desc->head),
+			  (usb_complete_t)ax_write_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, GFP_ATOMIC);
+	if (ret < 0) {
+		usb_autopm_put_interface_async(axdev->intf);
+		if (lso_skb != NULL) {
+			stats->tx_dropped++;
+			dev_kfree_skb_any (lso_skb);
+		}
+	} else {
+		if (lso_skb != NULL)
+			ax_lso_xmit(lso_skb, axdev->netdev);
+	}
+
+out_tx_fill:
+	return ret;
 }
 
-static int
-ax88179_ethtool_set_eee(struct usbnet *dev, struct ethtool_eee *data)
+static void ax_tx_bottom(struct ax_device *axdev)
 {
-	u16 tmp16 = ethtool_adv_to_mmd_eee_adv_t(data->advertised);
+	int res;
+
+	do {
+		struct tx_desc *desc;
 
-	return ax88179_phy_write_mmd_indirect(dev, MDIO_AN_EEE_ADV,
-					      MDIO_MMD_AN, tmp16);
+		if (skb_queue_empty(&axdev->tx_queue))
+			break;
+
+		desc = ax_get_tx_desc(axdev);
+		if (!desc)
+			break;
+
+		res = ax_tx_desc_fill(axdev, desc);
+		if (res) {
+			struct net_device *netdev = axdev->netdev;
+
+			if (res == -ENODEV) {
+				ax_set_unplug(axdev);
+				netif_device_detach(netdev);
+			} else {
+				struct net_device_stats *stats;
+				unsigned long flags;
+
+				stats = ax_get_stats(netdev);
+				stats->tx_dropped += desc->skb_num;
+
+				spin_lock_irqsave(&axdev->tx_lock, flags);
+				list_add_tail(&desc->list, &axdev->tx_free);
+				spin_unlock_irqrestore(&axdev->tx_lock, flags);
+			}
+		}
+	} while (res == 0);
 }
 
-static int ax88179_chk_eee(struct usbnet *dev)
+static void ax_bottom_half(struct ax_device *axdev)
 {
-	struct ethtool_cmd ecmd = { .cmd = ETHTOOL_GSET };
-	struct ax88179_data *priv = (struct ax88179_data *)dev->data;
+	if (test_bit(AX88179_UNPLUG, &axdev->flags))
+		return;
 
-	mii_ethtool_gset(&dev->mii, &ecmd);
+	if (!test_bit(AX88179_ENABLE, &axdev->flags))
+		return;
 
-	if (ecmd.duplex & DUPLEX_FULL) {
-		int eee_lp, eee_cap, eee_adv;
-		u32 lp, cap, adv, supported = 0;
+	if (!netif_carrier_ok(axdev->netdev))
+		return;
 
-		eee_cap = ax88179_phy_read_mmd_indirect(dev,
-							MDIO_PCS_EEE_ABLE,
-							MDIO_MMD_PCS);
-		if (eee_cap < 0) {
-			priv->eee_active = 0;
-			return false;
-		}
+	clear_bit(AX_SCHEDULE_NAPI, &axdev->flags);	
 
-		cap = mmd_eee_cap_to_ethtool_sup_t(eee_cap);
-		if (!cap) {
-			priv->eee_active = 0;
-			return false;
-		}
+	ax_tx_bottom(axdev);
+}
 
-		eee_lp = ax88179_phy_read_mmd_indirect(dev,
-						       MDIO_AN_EEE_LPABLE,
-						       MDIO_MMD_AN);
-		if (eee_lp < 0) {
-			priv->eee_active = 0;
-			return false;
-		}
+static void ax_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)
+{
+	skb->ip_summed = CHECKSUM_NONE;
+
+	/* checksum error bit is set */
+	if ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||
+	    (*pkt_hdr & AX_RXHDR_L4CSUM_ERR))
+		return;
 
-		eee_adv = ax88179_phy_read_mmd_indirect(dev,
-							MDIO_AN_EEE_ADV,
-							MDIO_MMD_AN);
+	/* It must be a TCP or UDP packet with a valid checksum */
+	if (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||
+	    ((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))
+		skb->ip_summed = CHECKSUM_UNNECESSARY;
+}
 
-		if (eee_adv < 0) {
-			priv->eee_active = 0;
-			return false;
+static int ax_rx_bottom(struct ax_device *axdev, int budget)
+{
+	unsigned long flags;
+	struct list_head *cursor, *next, rx_queue;
+	int ret = 0, work_done = 0;
+	struct napi_struct *napi = &axdev->napi;
+	struct net_device *netdev = axdev->netdev;
+	struct net_device_stats *stats = ax_get_stats(netdev);
+
+	if (!skb_queue_empty(&axdev->rx_queue)) {
+		while (work_done < budget) {
+			struct sk_buff *skb = __skb_dequeue(&axdev->rx_queue);						
+			unsigned int pkt_len;
+			if (!skb)
+				break;
+
+			pkt_len = skb->len;	
+			napi_gro_receive(napi, skb);
+			work_done++;
+			stats->rx_packets++;
+			stats->rx_bytes += pkt_len;
 		}
+	}
 
-		adv = mmd_eee_adv_to_ethtool_adv_t(eee_adv);
-		lp = mmd_eee_adv_to_ethtool_adv_t(eee_lp);
-		supported = (ecmd.speed == SPEED_1000) ?
-			     SUPPORTED_1000baseT_Full :
-			     SUPPORTED_100baseT_Full;
+	if (list_empty(&axdev->rx_done))
+		goto out1;
 
-		if (!(lp & adv & supported)) {
-			priv->eee_active = 0;
-			return false;
+	INIT_LIST_HEAD(&rx_queue);
+	spin_lock_irqsave(&axdev->rx_lock, flags);
+	list_splice_init(&axdev->rx_done, &rx_queue);
+	spin_unlock_irqrestore(&axdev->rx_lock, flags);
+
+	list_for_each_safe(cursor, next, &rx_queue) {
+		struct rx_desc *desc;
+		struct urb *urb;
+		u8 *rx_data;
+		u32 rx_hdr = 0, pkt_hdr = 0, pkt_hdr_curr = 0, hdr_off = 0;
+		u32 aa = 0;
+		int pkt_cnt = 0;
+
+		list_del_init(cursor);
+
+		desc = list_entry(cursor, struct rx_desc, list);
+		urb = desc->urb;
+		if (urb->actual_length < ETH_ZLEN)
+			goto submit;
+
+		/* RX Desc */
+		memcpy(&rx_hdr, (desc->head + urb->actual_length - 4),
+		       sizeof(rx_hdr));
+		le32_to_cpus(&rx_hdr);		
+
+		pkt_cnt = rx_hdr & 0xFF;
+		pkt_hdr_curr = hdr_off = rx_hdr >> 16;
+				
+		/* Check Bulk IN data */
+		aa = (urb->actual_length - (((pkt_cnt + 2) & 0xFE) * 4));		
+		if ((aa != hdr_off) ||
+		    (hdr_off >= urb->actual_length) ||
+		    (pkt_cnt == 0))
+			continue;
+		
+		rx_data = desc->head;
+		while (pkt_cnt--) {
+			u32 pkt_len;
+			struct sk_buff *skb;
+
+			memcpy(&pkt_hdr, (desc->head + pkt_hdr_curr),
+			       sizeof(pkt_hdr));
+			pkt_hdr_curr += 4;
+
+			/* limite the skb numbers for rx_queue */
+			if (unlikely(skb_queue_len(&axdev->rx_queue) >= 1000)) {
+				break;
+			}
+
+			le32_to_cpus(&pkt_hdr);
+			pkt_len = (pkt_hdr >> 16) & 0x1FFF;
+			pkt_len -= NET_IP_ALIGN;
+
+			/* Check CRC or runt packet */
+			if ((pkt_hdr & AX_RXHDR_CRC_ERR) ||
+			    (pkt_hdr & AX_RXHDR_DROP_ERR)) {
+				goto find_next_rx;
+			}			
+
+			skb = napi_alloc_skb(napi, pkt_len);
+			if (!skb) {
+				stats->rx_dropped++;
+				goto find_next_rx;
+			}
+			
+			skb_put(skb, pkt_len);		
+			memcpy(skb->data, (rx_data + NET_IP_ALIGN), pkt_len);
+
+			if (NET_IP_ALIGN == 0)
+				skb_pull(skb, 2);
+
+			ax_rx_checksum(skb, &pkt_hdr);
+		
+			skb->protocol = eth_type_trans(skb, netdev);
+
+			if (work_done < budget) {
+				napi_gro_receive(napi, skb);
+				work_done++;
+				stats->rx_packets++;
+				stats->rx_bytes += pkt_len;
+			} else {
+				__skb_queue_tail(&axdev->rx_queue, skb);
+			}
+find_next_rx:
+			rx_data += (pkt_len + 7) & 0xFFF8;
 		}
 
-		priv->eee_active = 1;
-		return true;
+submit:
+		if (!ret) {
+			ret = ax_submit_rx(axdev, desc, GFP_ATOMIC);
+		} else {
+			urb->actual_length = 0;
+			list_add_tail(&desc->list, next);
+		}
 	}
 
-	priv->eee_active = 0;
-	return false;
+	if (!list_empty(&rx_queue)) {
+		spin_lock_irqsave(&axdev->rx_lock, flags);
+		list_splice_tail(&rx_queue, &axdev->rx_done);
+		spin_unlock_irqrestore(&axdev->rx_lock, flags);
+	}
+out1:
+	return work_done;
 }
 
-static void ax88179_disable_eee(struct usbnet *dev)
+static
+int ax_submit_rx(struct ax_device *dev, struct rx_desc *desc, gfp_t mem_flags)
 {
-	u16 tmp16;
+	int ret;		
 
-	tmp16 = GMII_PHY_PGSEL_PAGE3;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
+	/* The rx would be stopped, so skip submitting */
+	if (test_bit(AX88179_UNPLUG, &dev->flags) ||
+	    !test_bit(AX88179_ENABLE, &dev->flags) ||
+	    !netif_carrier_ok(dev->netdev))
+		return 0;
+
+	usb_fill_bulk_urb(desc->urb, dev->udev, usb_rcvbulkpipe(dev->udev, 2),
+			  desc->head, AX88179_BUF_RX_SIZE,
+			  (usb_complete_t)ax_read_bulk_callback, desc);
+
+	ret = usb_submit_urb(desc->urb, mem_flags);
+	if (ret == -ENODEV) {
+		ax_set_unplug(dev);
+		netif_device_detach(dev->netdev);
+	} else if (ret) {
+		struct urb *urb = desc->urb;
+		unsigned long flags;
+
+		urb->actual_length = 0;
+		spin_lock_irqsave(&dev->rx_lock, flags);
+		list_add_tail(&desc->list, &dev->rx_done);
+		spin_unlock_irqrestore(&dev->rx_lock, flags);
 
-	tmp16 = 0x3246;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  MII_PHYADDR, 2, &tmp16);
+		netif_err(dev, rx_err, dev->netdev,
+			  "Couldn't submit rx[%p], ret = %d\n", desc, ret);
 
-	tmp16 = GMII_PHY_PGSEL_PAGE0;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
+		napi_schedule(&dev->napi);
+	}
+
+	return ret;
 }
 
-static void ax88179_enable_eee(struct usbnet *dev)
+/* End of TX/RX operations */
+
+/*
+ * NAPI Polling routine
+ */
+
+static inline int __ax_poll(struct ax_device *axdev, int budget)
 {
-	u16 tmp16;
+	struct napi_struct *napi = &axdev->napi;
+	int work_done;
+	struct sk_buff		*skb;
+	struct skb_data		*entry;
+
+	work_done = ax_rx_bottom(axdev, budget);
+	ax_bottom_half(axdev);
 
-	tmp16 = GMII_PHY_PGSEL_PAGE3;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
+	/* Free LSO skb */
+	while ((skb = skb_dequeue (&axdev->tx_lso_done)) != NULL) {			
+		entry = (struct skb_data *) skb->cb;
+		usb_free_urb (entry->urb);
+		dev_kfree_skb (skb);		
+	}
 
-	tmp16 = 0x3247;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  MII_PHYADDR, 2, &tmp16);
+	if (work_done < budget) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+		napi_complete_done(napi, work_done);
+#else
+		if (!napi_complete_done(napi, work_done))
+			goto out;
+#endif
+		if (!list_empty(&axdev->rx_done))
+			napi_schedule(napi);
+		else if (!skb_queue_empty(&axdev->tx_queue) &&
+			 !list_empty(&axdev->tx_free))
+			napi_schedule(napi);
+	}
 
-	tmp16 = GMII_PHY_PGSEL_PAGE5;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,10,0)
+out:
+#endif
+	return work_done;
+}
 
-	tmp16 = 0x0680;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  MII_BMSR, 2, &tmp16);
+static int ax_poll(struct napi_struct *napi, int budget)
+{
+	struct ax_device *axdev = container_of(napi, struct ax_device, napi);
 
-	tmp16 = GMII_PHY_PGSEL_PAGE0;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp16);
+	return __ax_poll(axdev, budget);
 }
 
-static int ax88179_get_eee(struct net_device *net, struct ethtool_eee *edata)
+/* End of NAPI Polling routine */
+
+static void ax_drop_queued_tx(struct ax_device *dev)
 {
-	struct usbnet *dev = netdev_priv(net);
-	struct ax88179_data *priv = (struct ax88179_data *)dev->data;
+	struct net_device_stats *stats = ax_get_stats(dev->netdev);
+	struct sk_buff_head skb_head, *tx_queue = &dev->tx_queue;
+	struct sk_buff *skb;
+
+	if (skb_queue_empty(tx_queue))
+		return;
 
-	edata->eee_enabled = priv->eee_enabled;
-	edata->eee_active = priv->eee_active;
+	__skb_queue_head_init(&skb_head);
+	spin_lock_bh(&tx_queue->lock);
+	skb_queue_splice_init(tx_queue, &skb_head);
+	spin_unlock_bh(&tx_queue->lock);
 
-	return ax88179_ethtool_get_eee(dev, edata);
+	while ((skb = __skb_dequeue(&skb_head))) {
+		dev_kfree_skb(skb);
+		stats->tx_dropped++;
+	}
 }
 
-static int ax88179_set_eee(struct net_device *net, struct ethtool_eee *edata)
+static void ax88179_tx_timeout(struct net_device *netdev)
 {
-	struct usbnet *dev = netdev_priv(net);
-	struct ax88179_data *priv = (struct ax88179_data *)dev->data;
-	int ret = -EOPNOTSUPP;
+	struct ax_device *dev = netdev_priv(netdev);
 
-	priv->eee_enabled = edata->eee_enabled;
-	if (!priv->eee_enabled) {
-		ax88179_disable_eee(dev);
-	} else {
-		priv->eee_enabled = ax88179_chk_eee(dev);
-		if (!priv->eee_enabled)
-			return -EOPNOTSUPP;
+	netif_warn(dev, tx_err, netdev, "Tx timeout\n");
 
-		ax88179_enable_eee(dev);
-	}
+	usb_queue_reset_device(dev->intf);
+}
 
-	ret = ax88179_ethtool_set_eee(dev, edata);
-	if (ret)
-		return ret;
+static netdev_tx_t ax88179_start_xmit(struct sk_buff *skb,
+				      struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
 
-	mii_nway_restart(&dev->mii);
+	skb_tx_timestamp(skb);
 
-	usbnet_link_change(dev, 0, 0);
+	skb_queue_tail(&axdev->tx_queue, skb);
 
-	return ret;
+	if (!list_empty(&axdev->tx_free)) {
+		if (test_bit(AX_SELECTIVE_SUSPEND, &axdev->flags)) {
+			set_bit(AX_SCHEDULE_NAPI, &axdev->flags);
+			schedule_delayed_work(&axdev->schedule, 0);
+		} else {
+			usb_mark_last_busy(axdev->udev);
+			napi_schedule(&axdev->napi);
+		}
+	} else if (skb_queue_len(&axdev->tx_queue) > axdev->tx_qlen) {
+		netif_stop_queue(netdev);
+	}
+
+	return NETDEV_TX_OK;
 }
 
-static int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
+static void ax_set_tx_qlen(struct ax_device *dev)
 {
-	struct usbnet *dev = netdev_priv(net);
-	return generic_mii_ioctl(&dev->mii, if_mii(rq), cmd, NULL);
+	struct net_device *netdev = dev->netdev;
+
+	dev->tx_qlen = AX88179_BUF_TX_SIZE / (netdev->mtu + ETH_FCS_LEN + 8);
 }
 
-static const struct ethtool_ops ax88179_ethtool_ops = {
-	.get_link		= ethtool_op_get_link,
-	.get_msglevel		= usbnet_get_msglevel,
-	.set_msglevel		= usbnet_set_msglevel,
-	.get_wol		= ax88179_get_wol,
-	.set_wol		= ax88179_set_wol,
-	.get_eeprom_len		= ax88179_get_eeprom_len,
-	.get_eeprom		= ax88179_get_eeprom,
-	.get_eee		= ax88179_get_eee,
-	.set_eee		= ax88179_set_eee,
-	.nway_reset		= usbnet_nway_reset,
-	.get_link_ksettings	= ax88179_get_link_ksettings,
-	.set_link_ksettings	= ax88179_set_link_ksettings,
-};
+static int ax_start_rx(struct ax_device *axdev)
+{
+	int i, ret = 0;
 
-static void ax88179_set_multicast(struct net_device *net)
+	INIT_LIST_HEAD(&axdev->rx_done);
+	for (i = 0; i < AX88179_MAX_RX; i++) {
+		INIT_LIST_HEAD(&axdev->rx_list[i].list);
+		ret = ax_submit_rx(axdev, &axdev->rx_list[i], GFP_KERNEL);
+		if (ret)
+			break;
+	}
+
+	if (ret && ++i < AX88179_MAX_RX) {
+		struct list_head rx_queue;
+		unsigned long flags;
+
+		INIT_LIST_HEAD(&rx_queue);
+
+		do {
+			struct rx_desc *desc = &axdev->rx_list[i++];
+			struct urb *urb = desc->urb;
+
+			urb->actual_length = 0;
+			list_add_tail(&desc->list, &rx_queue);
+		} while (i < AX88179_MAX_RX);
+
+		spin_lock_irqsave(&axdev->rx_lock, flags);
+		list_splice_tail(&rx_queue, &axdev->rx_done);
+		spin_unlock_irqrestore(&axdev->rx_lock, flags);
+	}
+
+	return ret;
+}
+
+static int ax_stop_rx(struct ax_device *axdev)
 {
-	struct usbnet *dev = netdev_priv(net);
-	struct ax88179_data *data = (struct ax88179_data *)dev->data;
-	u8 *m_filter = ((u8 *)dev->data) + 12;
+	int i;
 
-	data->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_IPE);
+	for (i = 0; i < AX88179_MAX_RX; i++)
+		usb_kill_urb(axdev->rx_list[i].urb);
 
-	if (net->flags & IFF_PROMISC) {
-		data->rxctl |= AX_RX_CTL_PRO;
-	} else if (net->flags & IFF_ALLMULTI ||
-		   netdev_mc_count(net) > AX_MAX_MCAST) {
-		data->rxctl |= AX_RX_CTL_AMALL;
-	} else if (netdev_mc_empty(net)) {
-		/* just broadcast and directed */
-	} else {
-		/* We use the 20 byte dev->data for our 8 byte filter buffer
-		 * to avoid allocating memory that is tricky to free later
-		 */
-		u32 crc_bits;
-		struct netdev_hw_addr *ha;
+	while (!skb_queue_empty(&axdev->rx_queue))
+		dev_kfree_skb(__skb_dequeue(&axdev->rx_queue));
+
+	return 0;
+}
 
-		memset(m_filter, 0, AX_MCAST_FLTSIZE);
+static void ax_disable(struct ax_device *axdev)
+{
+	int i;
 
-		netdev_for_each_mc_addr(ha, net) {
-			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
-			*(m_filter + (crc_bits >> 3)) |= (1 << (crc_bits & 7));
-		}
+	if (test_bit(AX88179_UNPLUG, &axdev->flags)) {
+		ax_drop_queued_tx(axdev);
+		return;
+	}	
 
-		ax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_MULFLTARY,
-					AX_MCAST_FLTSIZE, AX_MCAST_FLTSIZE,
-					m_filter);
+	ax_drop_queued_tx(axdev);
 
-		data->rxctl |= AX_RX_CTL_AM;
-	}
+	for (i = 0; i < AX88179_MAX_TX; i++)
+		usb_kill_urb(axdev->tx_list[i].urb);
 
-	ax88179_write_cmd_async(dev, AX_ACCESS_MAC, AX_RX_CTL,
-				2, 2, &data->rxctl);
+	ax_stop_rx(axdev);	
 }
 
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 39)
 static int
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
 ax88179_set_features(struct net_device *net, netdev_features_t features)
+#else
+ax88179_set_features(struct net_device *net, u32 features)
+#endif
+
 {
-	u8 tmp;
-	struct usbnet *dev = netdev_priv(net);
+	u8 *tmp8;
+	struct ax_device *dev = netdev_priv(net);	
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 3, 0)
 	netdev_features_t changed = net->features ^ features;
+#else
+	u32 changed = net->features ^ features;
+#endif
+
+	tmp8 = kmalloc(1, GFP_KERNEL);
+	if (!tmp8)
+		return -ENOMEM;
 
 	if (changed & NETIF_F_IP_CSUM) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
-		tmp ^= AX_TXCOE_TCP | AX_TXCOE_UDP;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
+		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL,
+				 1, 1, tmp8, 0);
+		*tmp8 ^= AX_TXCOE_TCP | AX_TXCOE_UDP;
+		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp8);
 	}
 
 	if (changed & NETIF_F_IPV6_CSUM) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
-		tmp ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &tmp);
+		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL,
+				 1, 1, tmp8, 0);
+		*tmp8 ^= AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp8);
 	}
 
 	if (changed & NETIF_F_RXCSUM) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);
-		tmp ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL,
+				 1, 1, tmp8, 0);
+		*tmp8 ^= AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
 		       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &tmp);
+		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp8);
 	}
 
+	kfree(tmp8);
+
 	return 0;
 }
+#endif
 
-static int ax88179_change_mtu(struct net_device *net, int new_mtu)
-{
-	struct usbnet *dev = netdev_priv(net);
-	u16 tmp16;
+static int ax_link_reset(struct ax_device *dev)
+{	
+	u8 reg8[5], link_sts;
+	u16 mode, reg16, delay = 10 * HZ;
+	u32 reg32;
+	unsigned long jtimeout = 0;
+
+	mode = AX_MEDIUM_TXFLOW_CTRLEN | AX_MEDIUM_RXFLOW_CTRLEN;
+	
+	ax88179_read_cmd_nopm(dev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
+			 1, 1, &link_sts, 0);
 
-	net->mtu = new_mtu;
-	dev->hard_mtu = net->mtu + net->hard_header_len;
+	jtimeout = jiffies + delay;
+	while(time_before(jiffies, jtimeout)) {
+		ax88179_read_cmd_nopm(dev, AX_ACCESS_PHY, AX88179_PHY_ID, GMII_PHY_PHYSR, 2, &reg16, 1);
+			if (reg16 & GMII_PHY_PHYSR_LINK) {
+			break;
+		}
+	}
 
-	if (net->mtu > 1500) {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				 2, 2, &tmp16);
-		tmp16 |= AX_MEDIUM_JUMBO_EN;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				  2, 2, &tmp16);
+	if (!(reg16 & GMII_PHY_PHYSR_LINK))
+		return 0;
+	else if (GMII_PHY_PHYSR_GIGA == (reg16 & GMII_PHY_PHYSR_SMASK)) {
+		mode |= AX_MEDIUM_GIGAMODE;
+		if (dev->netdev->mtu > 1500)
+			mode |= AX_MEDIUM_JUMBO_EN;
+
+		if (link_sts & AX_USB_SS)
+			memcpy(reg8, &AX88179_BULKIN_SIZE[0], 5);
+		else if (link_sts & AX_USB_HS)
+			memcpy(reg8, &AX88179_BULKIN_SIZE[1], 5);
+		else
+			memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	} else if (GMII_PHY_PHYSR_100 == (reg16 & GMII_PHY_PHYSR_SMASK)) {
+		mode |= AX_MEDIUM_PS;	/* Bit 9 : PS */
+		if (link_sts & (AX_USB_SS | AX_USB_HS))
+			memcpy(reg8, &AX88179_BULKIN_SIZE[2], 5);
+		else
+			memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+	} else
+		memcpy(reg8, &AX88179_BULKIN_SIZE[3], 5);
+
+	/* RX bulk configuration */
+	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, reg8);
+
+	if (reg16 & GMII_PHY_PHYSR_FULL)
+		mode |= AX_MEDIUM_FULL_DUPLEX;	/* Bit 1 : FD */	
+	
+	ax88179_read_cmd_nopm(dev, 0x81, 0x8c, 0, 4, &reg32, 1);
+	delay = HZ / 2;
+	if (reg32 & 0x40000000) {
+		u16 temp16 = 0;
+		ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &temp16);
+
+		/* Configure default medium type => giga */
+		ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				  2, 2, &mode);
+
+		jtimeout = jiffies + delay;
+
+		while (time_before(jiffies, jtimeout)) {
+			
+			ax88179_read_cmd_nopm(dev, 0x81, 0x8c, 0, 4, &reg32, 1);
+		
+			if (!(reg32 & 0x40000000))
+				break;
+
+			reg32 = 0x80000000;
+			ax88179_write_cmd(dev, 0x81, 0x8c, 0, 4, &reg32);
+		}
+		
+		temp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START | AX_RX_CTL_AP |
+		 	 AX_RX_CTL_AMALL | AX_RX_CTL_AB | AX_RX_CTL_IPE; 
+		ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL,
+				  2, 2, &temp16);
+	}
+
+	reg16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START | AX_RX_CTL_AP |
+		 	 AX_RX_CTL_AMALL | AX_RX_CTL_AB | AX_RX_CTL_IPE; 
+	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_RX_CTL,
+				  2, 2, &reg16);
+
+	mode |= AX_MEDIUM_RECEIVE_EN;
+
+	/* Configure default medium type => giga */
+	ax88179_write_cmd_nopm(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			  2, 2, &mode);	
+
+	if  (!test_bit(AX_SELECTIVE_SUSPEND, &dev->flags)) {
+		mii_check_media(&dev->mii, 1, 1);
+	}
+
+	return 0;
+}
+
+static void ax_set_carrier(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	struct napi_struct *napi = &axdev->napi;
+
+	if (axdev->link) {	
+		if (!netif_carrier_ok(netdev)) {
+				ax_link_reset(axdev);				
+				netif_stop_queue(netdev);
+				napi_disable(napi);
+				netif_carrier_on(netdev);
+				ax_start_rx(axdev);
+				napi_enable(napi);
+				netif_wake_queue(netdev);
+		} else if (netif_queue_stopped(netdev) &&
+			   skb_queue_len(&axdev->tx_queue) < axdev->tx_qlen) {
+				netif_wake_queue(netdev);
+		}
 	} else {
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				 2, 2, &tmp16);
-		tmp16 &= ~AX_MEDIUM_JUMBO_EN;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-				  2, 2, &tmp16);
+		if (netif_carrier_ok(netdev)) {
+				netif_carrier_off(netdev);
+				napi_disable(napi);
+				ax_disable(axdev);
+				napi_enable(napi);
+				netif_info(axdev, link, netdev, "link down\n");
+		}
+	}
+}
+
+static inline void __ax_work_func(struct ax_device *dev)
+{
+	if (test_bit(AX88179_UNPLUG, &dev->flags) || !netif_running(dev->netdev))
+		return;
+
+	if (usb_autopm_get_interface(dev->intf) < 0)
+		return;
+
+	if (!test_bit(AX88179_ENABLE, &dev->flags))
+		goto out1;
+
+	if (!mutex_trylock(&dev->control)) {
+		schedule_delayed_work(&dev->schedule, 0);
+		goto out1;
+	}
+
+	if (test_and_clear_bit(AX88179_LINK_CHG, &dev->flags))
+		ax_set_carrier(dev);
+
+	if (test_and_clear_bit(AX_SCHEDULE_NAPI, &dev->flags) &&
+	    netif_carrier_ok(dev->netdev))
+		napi_schedule(&dev->napi);
+
+	mutex_unlock(&dev->control);
+
+out1:
+	usb_autopm_put_interface(dev->intf);
+}
+
+static void ax_work_func_t(struct work_struct *work)
+{
+	struct ax_device *dev = container_of(work, struct ax_device, schedule.work);
+
+	__ax_work_func(dev);
+}
+
+/*
+ * IOCTL operations
+ */
+
+static int ax88179_ioctl(struct net_device *net, struct ifreq *rq, int cmd)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	return  generic_mii_ioctl(&axdev->mii, if_mii(rq), cmd, NULL);
+}
+/* End of IOCTL operations */
+
+/*
+ * Ethtool operations
+ */
+
+static void ax88179_get_drvinfo(struct net_device *net,
+				struct ethtool_drvinfo *info)
+{
+	struct ax_device *axdev = netdev_priv(net);
+
+	strlcpy (info->driver, MODULENAME, sizeof(info->driver));
+	strlcpy (info->version, DRIVER_VERSION, sizeof info->version);
+	usb_make_path (axdev->udev, info->bus_info, sizeof info->bus_info);
+
+	info->eedump_len = 0x3e;
+}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+static int ax88179_get_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	return mii_ethtool_gset(&axdev->mii, cmd);
+}
+
+static int ax88179_set_settings(struct net_device *net, struct ethtool_cmd *cmd)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	return mii_ethtool_sset(&axdev->mii, cmd);
+}
+#endif
+static u32 ax88179_get_msglevel(struct net_device *netdev)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	return axdev->msg_enable;
+}
+
+static void ax88179_set_msglevel(struct net_device *netdev, u32 value)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+
+	axdev->msg_enable = value;
+}
+
+static void
+ax88179_get_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	u8 reg8;	
+
+	if (ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE,
+			     1, 1, &reg8, 0) < 0) {
+		wolinfo->supported = 0;
+		wolinfo->wolopts = 0;
+		return;
 	}
 
-	/* max qlen depend on hard_mtu and rx_urb_size */
-	usbnet_update_max_qlen(dev);
+	wolinfo->supported = WAKE_PHY | WAKE_MAGIC;
+
+	if (reg8 & AX_MONITOR_MODE_RWLC)
+		wolinfo->wolopts |= WAKE_PHY;
+	if (reg8 & AX_MONITOR_MODE_RWMP)
+		wolinfo->wolopts |= WAKE_MAGIC;
+}
+
+static int
+ax88179_set_wol(struct net_device *net, struct ethtool_wolinfo *wolinfo)
+{
+	struct ax_device *axdev = netdev_priv(net);
+	u8 reg8 = 0;
+
+	if (wolinfo->wolopts & WAKE_PHY)
+		reg8 |= AX_MONITOR_MODE_RWLC;
+	else
+		reg8 &= ~AX_MONITOR_MODE_RWLC;
+
+	if (wolinfo->wolopts & WAKE_MAGIC)
+		reg8 |= AX_MONITOR_MODE_RWMP;
+	else
+		reg8 &= ~AX_MONITOR_MODE_RWMP;
+
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);	
 
 	return 0;
 }
 
+static
+int ax88179_get_link_ksettings(struct net_device *netdev,
+			       struct ethtool_link_ksettings *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	if (!axdev->mii.mdio_read)
+		return -EOPNOTSUPP;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_get_link_ksettings(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+out:
+	return ret;
+}
+
+static int ax88179_set_link_ksettings(struct net_device *netdev,
+				      const struct ethtool_link_ksettings *cmd)
+{
+	struct ax_device *axdev = netdev_priv(netdev);
+	int ret;
+
+	ret = usb_autopm_get_interface(axdev->intf);
+	if (ret < 0)
+		goto out;
+
+	mutex_lock(&axdev->control);
+
+	mii_ethtool_set_link_ksettings(&axdev->mii, cmd);
+
+	mutex_unlock(&axdev->control);
+
+	usb_autopm_put_interface(axdev->intf);
+
+out:
+	return ret;
+}
+
+static const struct ethtool_ops ax88179_ethtool_ops = {
+	.get_drvinfo  	= ax88179_get_drvinfo,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 20, 0)
+	.get_settings 	= ax88179_get_settings,
+	.set_settings 	= ax88179_set_settings,
+#endif	
+	.get_link     	= ethtool_op_get_link,
+	.get_msglevel 	= ax88179_get_msglevel,
+	.set_msglevel 	= ax88179_set_msglevel,
+	.get_wol 	= ax88179_get_wol,
+	.set_wol 	= ax88179_set_wol,
+	.get_link_ksettings = ax88179_get_link_ksettings,
+	.set_link_ksettings = ax88179_set_link_ksettings,
+};
+/* End of Ethtool operations */
+
+/*
+ * Network operations
+ */
+
 static int ax88179_set_mac_addr(struct net_device *net, void *p)
 {
-	struct usbnet *dev = netdev_priv(net);
+	struct ax_device *dev = netdev_priv(net);
 	struct sockaddr *addr = p;
 	int ret;
 
@@ -949,7 +1739,7 @@
 	if (!is_valid_ether_addr(addr->sa_data))
 		return -EADDRNOTAVAIL;
 
-	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);
+	memcpy(net->dev_addr, addr->sa_data, ETH_ALEN);	
 
 	/* Set the MAC address */
 	ret = ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
@@ -958,75 +1748,66 @@
 		return ret;
 
 	return 0;
-}
 
-static const struct net_device_ops ax88179_netdev_ops = {
-	.ndo_open		= usbnet_open,
-	.ndo_stop		= usbnet_stop,
-	.ndo_start_xmit		= usbnet_start_xmit,
-	.ndo_tx_timeout		= usbnet_tx_timeout,
-	.ndo_get_stats64	= usbnet_get_stats64,
-	.ndo_change_mtu		= ax88179_change_mtu,
-	.ndo_set_mac_address	= ax88179_set_mac_addr,
-	.ndo_validate_addr	= eth_validate_addr,
-	.ndo_do_ioctl		= ax88179_ioctl,
-	.ndo_set_rx_mode	= ax88179_set_multicast,
-	.ndo_set_features	= ax88179_set_features,
-};
+}
 
-static int ax88179_check_eeprom(struct usbnet *dev)
+static int ax_check_eeprom(struct ax_device *axdev)
 {
-	u8 i, buf, eeprom[20];
-	u16 csum, delay = HZ / 10;
-	unsigned long jtimeout;
+	u8 i = 0;
+	u8 buf[2];
+	u8 eeprom[20];
+	u16 csum = 0, delay = HZ / 10;
+	unsigned long jtimeout = 0;	
 
 	/* Read EEPROM content */
-	for (i = 0; i < 6; i++) {
-		buf = i;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,
-				      1, 1, &buf) < 0)
+	for (i = 0 ; i < 6; i++) {
+		buf[0] = i;
+		if (ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_ADDR,
+				      1, 1, buf) < 0) 
 			return -EINVAL;
 
-		buf = EEP_RD;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-				      1, 1, &buf) < 0)
+		buf[0] = EEP_RD;
+		if (ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+				      1, 1, buf) < 0) 
 			return -EINVAL;
 
 		jtimeout = jiffies + delay;
 		do {
-			ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-					 1, 1, &buf);
+			ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, buf, 0);
 
-			if (time_after(jiffies, jtimeout))
+			if (time_after(jiffies, jtimeout)) 
 				return -EINVAL;
+		} while (buf[0] & EEP_BUSY);
 
-		} while (buf & EEP_BUSY);
+		ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
+				 2, 2, &eeprom[i * 2], 0);
 
-		__ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
-				   2, 2, &eeprom[i * 2], 0);
-
-		if ((i == 0) && (eeprom[0] == 0xFF))
+		if ((i == 0) && (eeprom[0] == 0xFF)) 
 			return -EINVAL;
 	}
 
 	csum = eeprom[6] + eeprom[7] + eeprom[8] + eeprom[9];
 	csum = (csum >> 8) + (csum & 0xff);
-	if ((csum + eeprom[10]) != 0xff)
+
+	if ((csum + eeprom[10]) == 0xff) 
+		return AX_EEP_EFUSE_CORRECT;
+	else 
 		return -EINVAL;
 
-	return 0;
+	return AX_EEP_EFUSE_CORRECT;
 }
 
-static int ax88179_check_efuse(struct usbnet *dev, u16 *ledmode)
+static int ax_check_efuse(struct ax_device *axdev, void *ledmode)
 {
-	u8	i;
-	u8	efuse[64];
+	u8	i = 0;	
 	u16	csum = 0;
+	u8	efuse[64];
 
-	if (ax88179_read_cmd(dev, AX_ACCESS_EFUS, 0, 64, 64, efuse) < 0)
+	if (ax88179_read_cmd(axdev, AX_ACCESS_EFUSE, 0, 64, 64, efuse, 0) < 0)
 		return -EINVAL;
 
-	if (*efuse == 0xFF)
+	if (efuse[0] == 0xFF) 
 		return -EINVAL;
 
 	for (i = 0; i < 64; i++)
@@ -1035,24 +1816,36 @@
 	while (csum > 255)
 		csum = (csum & 0x00FF) + ((csum >> 8) & 0x00FF);
 
-	if (csum != 0xFF)
+	if (csum == 0xFF) {
+		memcpy((u8 *)ledmode, &efuse[51], 2);
+		return AX_EEP_EFUSE_CORRECT;
+	} else 
 		return -EINVAL;
 
-	*ledmode = (efuse[51] << 8) | efuse[52];
-
-	return 0;
+	return AX_EEP_EFUSE_CORRECT;
 }
 
-static int ax88179_convert_old_led(struct usbnet *dev, u16 *ledvalue)
+static int ax_convert_old_led(struct ax_device *axdev, u8 efuse, void *ledvalue)
 {
-	u16 led;
+	u8 ledmode = 0;
+	u16 reg16;
+	u16 led = 0;	
 
-	/* Loaded the old eFuse LED Mode */
-	if (ax88179_read_cmd(dev, AX_ACCESS_EEPROM, 0x3C, 1, 2, &led) < 0)
-		return -EINVAL;
+	/* loaded the old eFuse LED Mode */
+	if (efuse) {
+		if (ax88179_read_cmd(axdev, AX_ACCESS_EFUSE, 0x18,
+				     1, 2, &reg16, 1) < 0)
+			return -EINVAL;
+		ledmode = (u8)(reg16 & 0xFF);
+	} else { /* loaded the old EEprom LED Mode */
+		if (ax88179_read_cmd(axdev, AX_ACCESS_EEPROM, 0x3C,
+				     1, 2, &reg16, 1) < 0)
+			return -EINVAL;
+		ledmode = (u8) (reg16 >> 8);
+	}
+	netdev_dbg(axdev->netdev, "Old LED Mode = %02X\n", ledmode);
 
-	led >>= 8;
-	switch (led) {
+	switch (ledmode) {
 	case 0xFF:
 		led = LED0_ACTIVE | LED1_LINK_10 | LED1_LINK_100 |
 		      LED1_LINK_1000 | LED2_ACTIVE | LED2_LINK_10 |
@@ -1076,721 +1869,1012 @@
 		break;
 	}
 
-	*ledvalue = led;
+	memcpy((u8 *)ledvalue, &led, 2);
 
 	return 0;
 }
 
-static int ax88179_led_setting(struct usbnet *dev)
+static void ax_Gether_setting(struct ax_device *axdev)
 {
-	u8 ledfd, value = 0;
-	u16 tmp, ledact, ledlink, ledvalue = 0, delay = HZ / 10;
-	unsigned long jtimeout;
+	u16 reg16;
+
+	if (bGETH) {
+		reg16 = 0x03;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  31, 2, &reg16);
+		reg16 = 0x3247;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  25, 2, &reg16);
+		reg16 = 0x05;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  31, 2, &reg16);
+		reg16 = 0x0680;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  1, 2, &reg16);
+		reg16 = 0;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  31, 2, &reg16);
+	} else {
+		reg16 = 0x03;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  31, 2, &reg16);
+		reg16 = 0x3246;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  25, 2, &reg16);
+		reg16 = 0;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  31, 2, &reg16);
+	}
+}
 
-	/* Check AX88179 version. UA1 or UA2*/
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value);
+static int ax_LED_setting(struct ax_device *axdev)
+{	
+	u16 ledvalue = 0, delay = HZ / 10;
+	u16 ledact, ledlink;
+	u16 reg16;	
+	u8 value;
+	unsigned long jtimeout = 0;
+	
+	/* Check AX88179 version. UA1 or UA2 */
+	ax88179_read_cmd(axdev, AX_ACCESS_MAC, GENERAL_STATUS, 1, 1, &value, 0);
 
-	if (!(value & AX_SECLD)) {	/* UA1 */
+	/* UA1 */
+	if (!(value & AX_SECLD)) {
 		value = AX_GPIO_CTRL_GPIO3EN | AX_GPIO_CTRL_GPIO2EN |
 			AX_GPIO_CTRL_GPIO1EN;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_GPIO_CTRL,
+		if (ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_GPIO_CTRL,
 				      1, 1, &value) < 0)
 			return -EINVAL;
 	}
 
-	/* Check EEPROM */
-	if (!ax88179_check_eeprom(dev)) {
+	/* check EEprom */
+	if (ax_check_eeprom(axdev) == AX_EEP_EFUSE_CORRECT) {
 		value = 0x42;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_ADDR,
+		if (ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_ADDR,
 				      1, 1, &value) < 0)
 			return -EINVAL;
 
 		value = EEP_RD;
-		if (ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
+		if (ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
 				      1, 1, &value) < 0)
 			return -EINVAL;
 
 		jtimeout = jiffies + delay;
 		do {
-			ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_CMD,
-					 1, 1, &value);
+			ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, &value, 0);
+
+			ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_CMD,
+					 1, 1, &value, 0);
 
 			if (time_after(jiffies, jtimeout))
 				return -EINVAL;
-
 		} while (value & EEP_BUSY);
 
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,
-				 1, 1, &value);
+		ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_HIGH,
+				 1, 1, &value, 0);
 		ledvalue = (value << 8);
-
-		ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
-				 1, 1, &value);
+		ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_SROM_DATA_LOW,
+				 1, 1, &value, 0);
 		ledvalue |= value;
 
 		/* load internal ROM for defaule setting */
 		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
-			ax88179_convert_old_led(dev, &ledvalue);
+			ax_convert_old_led(axdev, 0, &ledvalue);
 
-	} else if (!ax88179_check_efuse(dev, &ledvalue)) {
+	} else if (ax_check_efuse(axdev, &ledvalue) ==
+				       AX_EEP_EFUSE_CORRECT) { /* check efuse */
 		if ((ledvalue == 0xFFFF) || ((ledvalue & LED_VALID) == 0))
-			ax88179_convert_old_led(dev, &ledvalue);
+			ax_convert_old_led(axdev, 0, &ledvalue);
 	} else {
-		ax88179_convert_old_led(dev, &ledvalue);
+		ax_convert_old_led(axdev, 0, &ledvalue);
 	}
 
-	tmp = GMII_PHY_PGSEL_EXT;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp);
+	reg16 = GMII_PHY_PAGE_SELECT_EXT;
+	ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHY_PAGE_SELECT, 2, &reg16);
 
-	tmp = 0x2c;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHYPAGE, 2, &tmp);
+	reg16 = 0x2c;
+	ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHYPAGE, 2, &reg16);
 
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			 GMII_LED_ACT, 2, &ledact);
+	ax88179_read_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_LED_ACTIVE, 2, &ledact, 1);
 
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			 GMII_LED_LINK, 2, &ledlink);
+	ax88179_read_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			 GMII_LED_LINK, 2, &ledlink, 1);
 
 	ledact &= GMII_LED_ACTIVE_MASK;
 	ledlink &= GMII_LED_LINK_MASK;
 
 	if (ledvalue & LED0_ACTIVE)
 		ledact |= GMII_LED0_ACTIVE;
-
 	if (ledvalue & LED1_ACTIVE)
 		ledact |= GMII_LED1_ACTIVE;
-
 	if (ledvalue & LED2_ACTIVE)
 		ledact |= GMII_LED2_ACTIVE;
 
 	if (ledvalue & LED0_LINK_10)
 		ledlink |= GMII_LED0_LINK_10;
-
 	if (ledvalue & LED1_LINK_10)
 		ledlink |= GMII_LED1_LINK_10;
-
 	if (ledvalue & LED2_LINK_10)
 		ledlink |= GMII_LED2_LINK_10;
 
 	if (ledvalue & LED0_LINK_100)
 		ledlink |= GMII_LED0_LINK_100;
-
 	if (ledvalue & LED1_LINK_100)
 		ledlink |= GMII_LED1_LINK_100;
-
 	if (ledvalue & LED2_LINK_100)
 		ledlink |= GMII_LED2_LINK_100;
 
 	if (ledvalue & LED0_LINK_1000)
 		ledlink |= GMII_LED0_LINK_1000;
-
 	if (ledvalue & LED1_LINK_1000)
 		ledlink |= GMII_LED1_LINK_1000;
-
 	if (ledvalue & LED2_LINK_1000)
 		ledlink |= GMII_LED2_LINK_1000;
-
-	tmp = ledact;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_LED_ACT, 2, &tmp);
-
-	tmp = ledlink;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_LED_LINK, 2, &tmp);
-
-	tmp = GMII_PHY_PGSEL_PAGE0;
-	ax88179_write_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			  GMII_PHY_PAGE_SELECT, 2, &tmp);
+	
+	ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_LED_ACTIVE, 2, &ledact);
+
+	ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_LED_LINK, 2, &ledlink);
+
+	reg16 = GMII_PHY_PAGE_SELECT_PAGE0;
+	ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+			  GMII_PHY_PAGE_SELECT, 2, &reg16);
 
 	/* LED full duplex setting */
-	ledfd = 0;
+	reg16 = 0;
 	if (ledvalue & LED0_FD)
-		ledfd |= 0x01;
+		reg16 |= 0x01;
 	else if ((ledvalue & LED0_USB3_MASK) == 0)
-		ledfd |= 0x02;
+		reg16 |= 0x02;
 
 	if (ledvalue & LED1_FD)
-		ledfd |= 0x04;
+		reg16 |= 0x04;
 	else if ((ledvalue & LED1_USB3_MASK) == 0)
-		ledfd |= 0x08;
+		reg16 |= 0x08;
 
-	if (ledvalue & LED2_FD)
-		ledfd |= 0x10;
-	else if ((ledvalue & LED2_USB3_MASK) == 0)
-		ledfd |= 0x20;
+	if (ledvalue & LED2_FD) /* LED2_FD */
+		reg16 |= 0x10;
+	else if ((ledvalue & LED2_USB3_MASK) == 0) /* LED2_USB3 */
+		reg16 |= 0x20;
 
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_LEDCTRL, 1, 1, &ledfd);
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, 0x73, 1, 1, &reg16);
 
 	return 0;
 }
 
-static int ax88179_bind(struct usbnet *dev, struct usb_interface *intf)
+static void ax_EEE_setting(struct ax_device *axdev)
 {
-	u8 buf[5];
-	u16 *tmp16;
-	u8 *tmp;
-	struct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;
-	struct ethtool_eee eee_data;
-
-	usbnet_get_endpoints(dev, intf);
-
-	tmp16 = (u16 *)buf;
-	tmp = (u8 *)buf;
+	u16 reg16;
+	
+	if (bEEE) { /* Enable */
+		reg16 = 0x07;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MACR, 2, &reg16);
+		reg16 = 0x3c;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MAADR, 2, &reg16);
+		reg16 = 0x4007;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MACR, 2, &reg16);
+		reg16 = 0x06;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MAADR, 2, &reg16);
+	} else {
+		reg16 = 0x07;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MACR, 2, &reg16);
+		reg16 = 0x3c;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MAADR, 2, &reg16);
+		reg16 = 0x4007;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MACR, 2, &reg16);
+		reg16 = 0x00;
+		ax88179_write_cmd(axdev, AX_ACCESS_PHY, AX88179_PHY_ID,
+				  GMII_PHY_MAADR, 2, &reg16);
+	}
+}
 
-	memset(ax179_data, 0, sizeof(*ax179_data));
+static int ax_hw_init(struct ax_device *axdev)
+{
+	u32 reg32;
+	u16 reg16;
+	u8 reg8;
+	u8 buf[6] = {0};	
+	
+	reg32 = 0;
+	ax88179_write_cmd(axdev, 0x81, 0x310, 0, 4, &reg32);
 
 	/* Power up ethernet PHY */
-	*tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
-	*tmp16 = AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
+	reg16 = 0;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
+	reg16 = AX_PHYPWR_RSTCTL_IPRL;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &reg16);
 	msleep(200);
 
-	*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);
+	reg8 = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
 	msleep(100);
+	
+	/* RX bulk configuration, default for USB3.0 to Giga*/
+	memcpy(buf, &AX88179_BULKIN_SIZE[0], 5);
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, buf);	
+
+	reg8 = 0x34;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW,
+			  1, 1, &reg8);
+
+	reg8 = 0x52;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
+			  1, 1, &reg8);
 
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
-			 ETH_ALEN, dev->net->dev_addr);
-	memcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);
+	/* Disable auto-power-OFF GigaPHY after ethx down*/
+	ax88179_write_cmd(axdev, 0x91, 0, 0, 0, NULL);
 
-	/* RX bulk configuration */
-	memcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);
+	/* Enable checksum offload */
+	reg8 = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
+	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, &reg8);
 
-	dev->rx_urb_size = 1024 * 20;
+	reg8 = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
+	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, &reg8);
 
-	*tmp = 0x34;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);
+	reg8 = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
+	       AX_MONITOR_MODE_RWLC | AX_MONITOR_MODE_RWMP;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_MONITOR_MODE, 1, 1, &reg8);	
 
-	*tmp = 0x52;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
-			  1, 1, tmp);
-
-	dev->net->netdev_ops = &ax88179_netdev_ops;
-	dev->net->ethtool_ops = &ax88179_ethtool_ops;
-	dev->net->needed_headroom = 8;
-	dev->net->max_mtu = 4088;
-
-	/* Initialize MII structure */
-	dev->mii.dev = dev->net;
-	dev->mii.mdio_read = ax88179_mdio_read;
-	dev->mii.mdio_write = ax88179_mdio_write;
-	dev->mii.phy_id_mask = 0xff;
-	dev->mii.reg_num_mask = 0xff;
-	dev->mii.phy_id = 0x03;
-	dev->mii.supports_gmii = 1;
+	ax_LED_setting(axdev);
 
-	dev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-			      NETIF_F_RXCSUM;
+	ax_EEE_setting(axdev);
 
-	dev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-				 NETIF_F_RXCSUM;
+	ax_Gether_setting(axdev);
 
-	/* Enable checksum offload */
-	*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
-	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);
+	/* Restart autoneg */
+	mii_nway_restart(&axdev->mii);
 
-	*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
-	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);
+	netif_carrier_off(axdev->netdev);
 
-	/* Configure RX control register => start operation */
-	*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |
-		 AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);
-
-	*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
-	       AX_MONITOR_MODE_RWMP;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);
+	return 0;
+
+}
+
+static int ax88179_open(struct net_device *netdev)
+{
+	struct ax_device *dev = netdev_priv(netdev);
+	int res = 0;
 
-	/* Configure default medium type => giga */
-	*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |
-		 AX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |
-		 AX_MEDIUM_GIGAMODE;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, tmp16);
-
-	ax88179_led_setting(dev);
-
-	ax179_data->eee_enabled = 0;
-	ax179_data->eee_active = 0;
-
-	ax88179_disable_eee(dev);
-
-	ax88179_ethtool_get_eee(dev, &eee_data);
-	eee_data.advertised = 0;
-	ax88179_ethtool_set_eee(dev, &eee_data);
 
-	/* Restart autoneg */
-	mii_nway_restart(&dev->mii);
 
-	usbnet_link_change(dev, 0, 0);
+	res = ax_alloc_buffer(dev);
+	if (res) 
+		goto out;	
+
+	res = usb_autopm_get_interface(dev->intf);
+	if (res < 0) 
+		goto out_free;	
+
+	mutex_lock(&dev->control);
+
+	res = ax_hw_init(dev);
+	if (res < 0)
+		goto out_free;
+
+	netif_carrier_off(netdev);	
+	
+	smp_mb__before_atomic();
+	set_bit(AX88179_ENABLE, &dev->flags);
+	smp_mb__after_atomic();	
+
+	ax_set_tx_qlen(dev);
+
+	res = usb_submit_urb(dev->intr_urb, GFP_KERNEL);
+	if (res) {
+		if (res == -ENODEV)
+			netif_device_detach(dev->netdev);
+		netif_warn(dev, ifup, netdev, "intr_urb submit failed: %d\n",
+			   res);
+		goto out_unlock;
+	}
+
+	napi_enable(&dev->napi);
+	netif_start_queue(netdev);
+
+	mutex_unlock(&dev->control);
+
+	usb_autopm_put_interface(dev->intf);
 
 	return 0;
+
+out_unlock:
+	mutex_unlock(&dev->control);
+	usb_autopm_put_interface(dev->intf);
+out_free:
+	ax_free_buffer(dev);
+out:
+	return res;
 }
 
-static void ax88179_unbind(struct usbnet *dev, struct usb_interface *intf)
+static int ax88179_close(struct net_device *netdev)
 {
-	u16 tmp16;
+	struct ax_device *axdev = netdev_priv(netdev);
+	u16 reg16;
+	u8 reg8;
+	int res = 0;
+
+	netif_carrier_off(netdev);	
 
 	/* Configure RX control register => stop operation */
-	tmp16 = AX_RX_CTL_STOP;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &tmp16);
+	reg16 = AX_RX_CTL_STOP;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+			  2, 2, &reg16);
 
-	tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &tmp16);
+	reg8 = 0;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, &reg8);
 
 	/* Power down ethernet PHY */
-	tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, &tmp16);
+	reg16 = AX_PHYPWR_RSTCTL_BZ;
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+			  2, 2, &reg16);
+	msleep(200);
+
+	napi_disable(&axdev->napi);
+	smp_mb__before_atomic();
+	clear_bit(AX88179_ENABLE, &axdev->flags);
+	smp_mb__after_atomic();
+	usb_kill_urb(axdev->intr_urb);
+	cancel_delayed_work_sync(&axdev->schedule);
+	netif_stop_queue(axdev->netdev);	
+
+	res = usb_autopm_get_interface(axdev->intf);
+	if (res < 0 || test_bit(AX88179_UNPLUG, &axdev->flags)) {
+		ax_drop_queued_tx(axdev);
+		ax_stop_rx(axdev);
+	} 
+
+	ax_disable(axdev);
+
+	ax_free_buffer(axdev);
+
+	return res;
 }
 
-static void
-ax88179_rx_checksum(struct sk_buff *skb, u32 *pkt_hdr)
+static int ax88179_change_mtu(struct net_device *net, int new_mtu)
 {
-	skb->ip_summed = CHECKSUM_NONE;
+	struct ax_device *axdev = netdev_priv(net);
+	u16 reg16;
 
-	/* checksum error bit is set */
-	if ((*pkt_hdr & AX_RXHDR_L3CSUM_ERR) ||
-	    (*pkt_hdr & AX_RXHDR_L4CSUM_ERR))
-		return;
+	if (new_mtu <= 0 || new_mtu > 4088)
+		return -EINVAL;
 
-	/* It must be a TCP or UDP packet with a valid checksum */
-	if (((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_TCP) ||
-	    ((*pkt_hdr & AX_RXHDR_L4_TYPE_MASK) == AX_RXHDR_L4_TYPE_UDP))
-		skb->ip_summed = CHECKSUM_UNNECESSARY;
+	net->mtu = new_mtu;
+
+	if (net->mtu > 1500) {
+		ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				 2, 2, &reg16, 1);
+		reg16 |= AX_MEDIUM_JUMBO_EN;
+		ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				  2, 2, &reg16);
+	} else {
+		ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				 2, 2, &reg16, 1);
+		reg16 &= ~AX_MEDIUM_JUMBO_EN;
+		ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				  2, 2, &reg16);
+	}
+
+	return 0;
 }
 
-static int ax88179_rx_fixup(struct usbnet *dev, struct sk_buff *skb)
+static void ax88179_set_multicast(struct net_device *net)
 {
-	struct sk_buff *ax_skb;
-	int pkt_cnt;
-	u32 rx_hdr;
-	u16 hdr_off;
-	u32 *pkt_hdr;
+	struct ax_device *axdev = netdev_priv(net);
+	u8 *m_filter = axdev->m_filter;
+	int mc_count = 0;
 
-	/* This check is no longer done by usbnet */
-	if (skb->len < dev->net->hard_header_len)
-		return 0;
+	if (!test_bit(AX88179_ENABLE, &axdev->flags)) {
+		return;
+	}
 
-	skb_trim(skb, skb->len - 4);
-	memcpy(&rx_hdr, skb_tail_pointer(skb), 4);
-	le32_to_cpus(&rx_hdr);
-
-	pkt_cnt = (u16)rx_hdr;
-	hdr_off = (u16)(rx_hdr >> 16);
-	pkt_hdr = (u32 *)(skb->data + hdr_off);
-
-	while (pkt_cnt--) {
-		u16 pkt_len;
-
-		le32_to_cpus(pkt_hdr);
-		pkt_len = (*pkt_hdr >> 16) & 0x1fff;
-
-		/* Check CRC or runt packet */
-		if ((*pkt_hdr & AX_RXHDR_CRC_ERR) ||
-		    (*pkt_hdr & AX_RXHDR_DROP_ERR)) {
-			skb_pull(skb, (pkt_len + 7) & 0xFFF8);
-			pkt_hdr++;
-			continue;
-		}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+	mc_count = net->mc_count;
+#else
+	mc_count = netdev_mc_count(net);
+#endif
 
-		if (pkt_cnt == 0) {
-			/* Skip IP alignment psudo header */
-			skb_pull(skb, 2);
-			skb->len = pkt_len;
-			skb_set_tail_pointer(skb, pkt_len);
-			skb->truesize = pkt_len + sizeof(struct sk_buff);
-			ax88179_rx_checksum(skb, pkt_hdr);
-			return 1;
-		}
-
-		ax_skb = skb_clone(skb, GFP_ATOMIC);
-		if (ax_skb) {
-			ax_skb->len = pkt_len;
-			ax_skb->data = skb->data + 2;
-			skb_set_tail_pointer(ax_skb, pkt_len);
-			ax_skb->truesize = pkt_len + sizeof(struct sk_buff);
-			ax88179_rx_checksum(ax_skb, pkt_hdr);
-			usbnet_skb_return(dev, ax_skb);
-		} else {
-			return 0;
+	axdev->rxctl = (AX_RX_CTL_START | AX_RX_CTL_AB | AX_RX_CTL_IPE);
+
+	if (net->flags & IFF_PROMISC) {
+		axdev->rxctl |= AX_RX_CTL_PRO;
+	} else if (net->flags & IFF_ALLMULTI
+		   || mc_count > AX_MAX_MCAST) {
+		axdev->rxctl |= AX_RX_CTL_AMALL;
+	} else if (mc_count == 0) {
+		/* just broadcast and directed */
+	} else {
+		/* We use the 20 byte dev->data
+		 * for our 8 byte filter buffer
+		 * to avoid allocating memory that
+		 * is tricky to free later */
+		u32 crc_bits = 0;
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 35)
+		struct dev_mc_list *mc_list = net->mc_list;
+		int i = 0;
+
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+
+		/* Build the multicast hash filter. */
+		for (i = 0; i < net->mc_count; i++) {
+			crc_bits =
+			    ether_crc(ETH_ALEN,
+				      mc_list->dmi_addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+			mc_list = mc_list->next;
 		}
+#else
+		struct netdev_hw_addr *ha = NULL;
+		memset(m_filter, 0, AX_MCAST_FILTER_SIZE);
+		netdev_for_each_mc_addr(ha, net) {
+			crc_bits = ether_crc(ETH_ALEN, ha->addr) >> 26;
+			*(m_filter + (crc_bits >> 3)) |=
+				1 << (crc_bits & 7);
+		}
+#endif
+		ax88179_write_cmd_async(axdev, AX_ACCESS_MAC,
+					AX_MULTI_FILTER_ARRY,
+					AX_MCAST_FILTER_SIZE,
+					AX_MCAST_FILTER_SIZE, m_filter);
 
-		skb_pull(skb, (pkt_len + 7) & 0xFFF8);
-		pkt_hdr++;
+		axdev->rxctl |= AX_RX_CTL_AM;
 	}
-	return 1;
+
+	ax88179_write_cmd_async(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				2, 2, &axdev->rxctl);
 }
 
-static struct sk_buff *
-ax88179_tx_fixup(struct usbnet *dev, struct sk_buff *skb, gfp_t flags)
-{
-	u32 tx_hdr1, tx_hdr2;
-	int frame_size = dev->maxpacket;
-	int mss = skb_shinfo(skb)->gso_size;
-	int headroom;
+static const struct net_device_ops ax88179_netdev_ops = {
+	.ndo_open		= ax88179_open,
+	.ndo_stop		= ax88179_close,
+	.ndo_do_ioctl		= ax88179_ioctl,
+	.ndo_start_xmit		= ax88179_start_xmit,
+	.ndo_tx_timeout		= ax88179_tx_timeout,
+	.ndo_set_features	= ax88179_set_features,
+	.ndo_set_rx_mode	= ax88179_set_multicast,
+	.ndo_set_mac_address	= ax88179_set_mac_addr,
+	.ndo_change_mtu		= ax88179_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
+/* End of Network operations */
 
-	tx_hdr1 = skb->len;
-	tx_hdr2 = mss;
-	if (((skb->len + 8) % frame_size) == 0)
-		tx_hdr2 |= 0x80008000;	/* Enable padding */
+/*
+ * Driver Operartion
+ */
 
-	headroom = skb_headroom(skb) - 8;
+static int ax_access_eeprom_mac(struct ax_device *axdev, u8 *buf, u8 offset, int wflag)
+{
+	int ret = 0, i;
+	u16* tmp = (u16*)buf;
+	
+	for (i = 0; i < (ETH_ALEN >> 1); i++) {
+		if (wflag) {
+			u16 tmp16;			
+			
+			tmp16 = cpu_to_le16(*(tmp + i));
+			ret = ax88179_write_cmd(axdev, AX_ACCESS_EEPROM,
+						offset + i, 1, 2, &tmp16);
+			if (ret < 0)
+				break;
 
-	if ((skb_header_cloned(skb) || headroom < 0) &&
-	    pskb_expand_head(skb, headroom < 0 ? 8 : 0, 0, GFP_ATOMIC)) {
-		dev_kfree_skb_any(skb);
-		return NULL;
+			mdelay(15);
+		}
+		else {
+			ret = ax88179_read_cmd(axdev, AX_ACCESS_EEPROM,
+						offset + i, 1, 2, tmp + i, 0);
+			if (ret < 0)
+				break;
+		}
 	}
 
-	skb_push(skb, 4);
-	cpu_to_le32s(&tx_hdr2);
-	skb_copy_to_linear_data(skb, &tx_hdr2, 4);
+	if (!wflag) {
+		if (ret < 0) {
+			netdev_dbg(axdev->netdev,
+				   "Failed to read MAC address from EEPROM: %d\n",
+				   ret);
+			return ret;
+		}
+		memcpy(axdev->netdev->dev_addr, buf, ETH_ALEN);
+	}
+	else {
+		/* reload eeprom data */
+		ret = ax88179_write_cmd(axdev, AX_RELOAD_EEPROM_EFUSE, 0, 0, 0, 0);
+		if (ret < 0) 
+			return ret;		
+	}
 
-	skb_push(skb, 4);
-	cpu_to_le32s(&tx_hdr1);
-	skb_copy_to_linear_data(skb, &tx_hdr1, 4);
+	return 0;
+}
 
-	return skb;
+static int ax_check_ether_addr(struct ax_device *axdev)
+{
+	unsigned char *tmp = (unsigned char*)axdev->netdev->dev_addr;
+	u8 default_mac[6] = {0, 0x0e, 0xc6, 0x81, 0x79, 0x01};
+	u8 default_mac_178a[6] = {0, 0x0e, 0xc6, 0x81, 0x78, 0x01};
+
+	if (((*((u8*)tmp) == 0) &&
+	    (*((u8*)tmp + 1) == 0) &&
+	    (*((u8*)tmp + 2) == 0)) ||
+	    !is_valid_ether_addr((u8*)tmp) ||
+	    !memcmp(axdev->netdev->dev_addr, default_mac, ETH_ALEN) ||
+	    !memcmp(axdev->netdev->dev_addr, default_mac_178a, ETH_ALEN)) {
+
+		printk("Found invalid EEPROM MAC address value\n");
+
+		eth_random_addr(tmp);
+
+		*tmp = 0;
+		*(tmp + 1) = 0x0E;
+		*(tmp + 2) = 0xC6;
+		*(tmp + 3) = 0x8E;
+
+		return -EADDRNOTAVAIL;	
+	} 
+	return 0;
 }
 
-static int ax88179_link_reset(struct usbnet *dev)
+static int ax_get_mac(struct ax_device *axdev, u8* buf)
 {
-	struct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;
-	u8 tmp[5], link_sts;
-	u16 mode, tmp16, delay = HZ / 10;
-	u32 tmp32 = 0x40000000;
-	unsigned long jtimeout;
+	int ret, i;
 
-	jtimeout = jiffies + delay;
-	while (tmp32 & 0x40000000) {
-		mode = 0;
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &mode);
-		ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2,
-				  &ax179_data->rxctl);
+	ret = ax_access_eeprom_mac(axdev, buf, 0x0, 0);
+	if (ret < 0)
+		goto out;
+
+	if (ax_check_ether_addr(axdev)) {
+		ret = ax_access_eeprom_mac(axdev, axdev->netdev->dev_addr, 0x0, 1);
+		if (ret < 0) {
+			netdev_err(axdev->netdev,
+				   "Failed to write MAC to EEPROM: %d", ret);
+			goto out;
+		}
+
+		msleep(5);
 
-		/*link up, check the usb device control TX FIFO full or empty*/
-		ax88179_read_cmd(dev, 0x81, 0x8c, 0, 4, &tmp32);
+		ret = ax88179_read_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID,
+				       ETH_ALEN, ETH_ALEN, buf, 0);
+		if (ret < 0) {
+			netdev_err(axdev->netdev,
+				   "Failed to read MAC address: %d", ret);
+			goto out;
+		}
 
-		if (time_after(jiffies, jtimeout))
-			return 0;
+		for (i = 0; i < ETH_ALEN; i++)
+			if (*(axdev->netdev->dev_addr + i) != *((u8*)buf + i)) {
+				netdev_warn(axdev->netdev,
+					    "Found invalid EEPROM part or \
+					    non-EEPROM");
+				break;
+			}
+	}
+
+	memcpy(axdev->netdev->perm_addr, axdev->netdev->dev_addr, ETH_ALEN);
+
+	ax88179_write_cmd(axdev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN,
+			  ETH_ALEN, axdev->netdev->dev_addr);
+	
+	if (ret < 0) {
+		netdev_err(axdev->netdev, "Failed to write MAC address: %d", ret);
+		goto out;
 	}
 
-	mode = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |
-	       AX_MEDIUM_RXFLOW_CTRLEN;
+	return 0;
+out:
+	return ret;
+}
+
+static int ax88179_probe(struct usb_interface *intf,
+			 const struct usb_device_id *id)
+{
+	struct usb_device *udev = interface_to_usbdev(intf);
+	//struct usb_driver *driver = to_usb_driver(intf->dev.driver);	
+	struct net_device *netdev;
+	struct ax_device *axdev;
+	u8 mac_addr[6] = {0};
+	int ret;
+
+	netdev = alloc_etherdev(sizeof(struct ax_device));
+	if (!netdev) {
+		dev_err(&intf->dev, "Out of memory\n");
+		return -ENOMEM;
+	}
+	
+	axdev = netdev_priv(netdev);
 
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, PHYSICAL_LINK_STATUS,
-			 1, 1, &link_sts);
+	netdev->watchdog_timeo = AX88179_TX_TIMEOUT;
+	netdev->netdev_ops = &ax88179_netdev_ops;
+	netdev->ethtool_ops = &ax88179_ethtool_ops;
+
+	axdev->udev = udev;
+	axdev->netdev = netdev;
+	axdev->intf = intf;
+
+	mutex_init(&axdev->control);
+	INIT_DELAYED_WORK(&axdev->schedule, ax_work_func_t);	
+
+	netdev->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM;
+	netdev->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
+			       NETIF_F_SG | NETIF_F_TSO;	
+
+	axdev->mii.supports_gmii = 1;
+	axdev->mii.dev = netdev;
+	axdev->mii.mdio_read = ax88179_mdio_read;
+	axdev->mii.mdio_write = ax88179_mdio_write;
+	axdev->mii.phy_id_mask = 0xff;
+	axdev->mii.reg_num_mask = 0xff;
+	axdev->mii.phy_id = AX88179_PHY_ID;
+	axdev->mii.force_media = 0;
+	axdev->mii.advertising = ADVERTISE_10HALF | ADVERTISE_10FULL |
+			         ADVERTISE_100HALF | ADVERTISE_100FULL;
+	axdev->advertising = ADVERTISED_10baseT_Half | ADVERTISED_10baseT_Full |
+			   ADVERTISED_100baseT_Half | ADVERTISED_100baseT_Full |
+			   ADVERTISED_1000baseT_Full;
+	intf->needs_remote_wakeup = 1;
 
-	ax88179_read_cmd(dev, AX_ACCESS_PHY, AX88179_PHY_ID,
-			 GMII_PHY_PHYSR, 2, &tmp16);
+	memset(mac_addr, 0, ETH_ALEN);
+	ret = ax_get_mac(axdev, mac_addr);
+	if (ret)
+		goto out;
+	netdev_dbg(axdev->netdev, "MAC [%02x-%02x-%02x-%02x-%02x-%02x]\n",
+		   axdev->netdev->dev_addr[0], axdev->netdev->dev_addr[1],
+		   axdev->netdev->dev_addr[2], axdev->netdev->dev_addr[3],
+		   axdev->netdev->dev_addr[4], axdev->netdev->dev_addr[5]);
+
+	usb_set_intfdata(intf, axdev);
+	netif_napi_add(netdev, &axdev->napi, ax_poll, AX88179_NAPI_WEIGHT);
+
+	SET_NETDEV_DEV(netdev, &intf->dev);
+	ret = register_netdev(netdev);
+	if (ret != 0) {
+		netif_err(axdev, probe, netdev,
+			  "couldn't register the device\n");
+		goto out1;
+	}	
 
-	if (!(tmp16 & GMII_PHY_PHYSR_LINK)) {
-		return 0;
-	} else if (GMII_PHY_PHYSR_GIGA == (tmp16 & GMII_PHY_PHYSR_SMASK)) {
-		mode |= AX_MEDIUM_GIGAMODE | AX_MEDIUM_EN_125MHZ;
-		if (dev->net->mtu > 1500)
-			mode |= AX_MEDIUM_JUMBO_EN;
+	 /* usb_enable_autosuspend(udev); */
+	
+	return 0;
+out1:
+	netif_napi_del(&axdev->napi);
+	usb_set_intfdata(intf, NULL);
+out:
+	free_netdev(netdev);
+	return ret;
+}
 
-		if (link_sts & AX_USB_SS)
-			memcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);
-		else if (link_sts & AX_USB_HS)
-			memcpy(tmp, &AX88179_BULKIN_SIZE[1], 5);
-		else
-			memcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);
-	} else if (GMII_PHY_PHYSR_100 == (tmp16 & GMII_PHY_PHYSR_SMASK)) {
-		mode |= AX_MEDIUM_PS;
+static void ax88179_disconnect(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
 
-		if (link_sts & (AX_USB_SS | AX_USB_HS))
-			memcpy(tmp, &AX88179_BULKIN_SIZE[2], 5);
-		else
-			memcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);
-	} else {
-		memcpy(tmp, &AX88179_BULKIN_SIZE[3], 5);
+	usb_set_intfdata(intf, NULL);
+	if (axdev) {
+		ax_set_unplug(axdev);
+		netif_napi_del(&axdev->napi);
+		unregister_netdev(axdev->netdev);		
+		free_netdev(axdev->netdev);
 	}
+}
 
-	/* RX bulk configuration */
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);
 
-	dev->rx_urb_size = (1024 * (tmp[3] + 2));
+static int ax88179_pre_reset(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	struct net_device *netdev;
 
-	if (tmp16 & GMII_PHY_PHYSR_FULL)
-		mode |= AX_MEDIUM_FULL_DUPLEX;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, &mode);
+	if (!axdev)
+		return 0;
 
-	ax179_data->eee_enabled = ax88179_chk_eee(dev);
+	netdev = axdev->netdev;
+	if (!netif_running(netdev))
+		return 0;
 
-	netif_carrier_on(dev->net);
+	netif_stop_queue(netdev);
+	napi_disable(&axdev->napi);
+	smp_mb__before_atomic();
+	clear_bit(AX88179_ENABLE, &axdev->flags);
+	smp_mb__after_atomic();
+	usb_kill_urb(axdev->intr_urb);
+	cancel_delayed_work_sync(&axdev->schedule);
 
 	return 0;
 }
 
-static int ax88179_reset(struct usbnet *dev)
+static int ax88179_post_reset(struct usb_interface *intf)
 {
-	u8 buf[5];
-	u16 *tmp16;
-	u8 *tmp;
-	struct ax88179_data *ax179_data = (struct ax88179_data *)dev->data;
-	struct ethtool_eee eee_data;
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	struct net_device *netdev;
 
-	tmp16 = (u16 *)buf;
-	tmp = (u8 *)buf;
+	if (!axdev)
+		return 0;
 
-	/* Power up ethernet PHY */
-	*tmp16 = 0;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
+	netdev = axdev->netdev;
+	if (!netif_running(netdev))
+		return 0;
 
-	*tmp16 = AX_PHYPWR_RSTCTL_IPRL;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL, 2, 2, tmp16);
-	msleep(200);
+	smp_mb__before_atomic();
+	set_bit(AX88179_ENABLE, &axdev->flags);
+	smp_mb__after_atomic();
+	if (netif_carrier_ok(netdev)) {
+		mutex_lock(&axdev->control);
+		ax_start_rx(axdev);
+		mutex_unlock(&axdev->control);
+	}
 
-	*tmp = AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_CLK_SELECT, 1, 1, tmp);
-	msleep(100);
+	napi_enable(&axdev->napi);
+	netif_wake_queue(netdev);
+	usb_submit_urb(axdev->intr_urb, GFP_KERNEL);
 
-	/* Ethernet PHY Auto Detach*/
-	ax88179_auto_detach(dev, 0);
+	if (!list_empty(&axdev->rx_done))
+		napi_schedule(&axdev->napi);
 
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_NODE_ID, ETH_ALEN, ETH_ALEN,
-			 dev->net->dev_addr);
-	memcpy(dev->net->perm_addr, dev->net->dev_addr, ETH_ALEN);
+	return 0;
+}
 
-	/* RX bulk configuration */
-	memcpy(tmp, &AX88179_BULKIN_SIZE[0], 5);
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_BULKIN_QCTRL, 5, 5, tmp);
+static int ax_system_resume(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
 
-	dev->rx_urb_size = 1024 * 20;
+	netif_device_attach(netdev);
 
-	*tmp = 0x34;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_LOW, 1, 1, tmp);
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+		u16 reg16;
+		u8 reg8;
+
+		netif_carrier_off(netdev);		
+
+		/* Power up ethernet PHY */
+		reg16 = 0;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+				       2, 2, &reg16);
+		usleep_range(1000, 2000);
+		reg16 = AX_PHYPWR_RSTCTL_IPRL;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+				       2, 2, &reg16);
+		msleep(200);		
+
+		/* change clock */	
+		ax88179_read_cmd_nopm(axdev, AX_ACCESS_MAC,  AX_CLK_SELECT,
+				      1, 1, &reg8, 0);
+		reg8 |= AX_CLK_SELECT_ACS | AX_CLK_SELECT_BCS;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_CLK_SELECT,
+				       1, 1, &reg8);
+		msleep(100);
+
+		/* Configure RX control register => start operation */
+		reg16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_START | AX_RX_CTL_AP |
+			 AX_RX_CTL_AMALL | AX_RX_CTL_AB | AX_RX_CTL_IPE;		
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				       2, 2, &reg16);
+		
+		smp_mb__before_atomic();
+		set_bit(AX88179_ENABLE, &axdev->flags);
+		smp_mb__after_atomic();		
 
-	*tmp = 0x52;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_PAUSE_WATERLVL_HIGH,
-			  1, 1, tmp);
+		usb_submit_urb(axdev->intr_urb, GFP_NOIO);
+	}
 
-	dev->net->features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-			      NETIF_F_RXCSUM;
+	return 0;
+}
 
-	dev->net->hw_features |= NETIF_F_IP_CSUM | NETIF_F_IPV6_CSUM |
-				 NETIF_F_RXCSUM;
+static int ax_runtime_resume(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
 
-	/* Enable checksum offload */
-	*tmp = AX_RXCOE_IP | AX_RXCOE_TCP | AX_RXCOE_UDP |
-	       AX_RXCOE_TCPV6 | AX_RXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RXCOE_CTL, 1, 1, tmp);
+	if (netif_running(netdev) && (netdev->flags & IFF_UP)) {
+		struct napi_struct *napi = &axdev->napi;
 
-	*tmp = AX_TXCOE_IP | AX_TXCOE_TCP | AX_TXCOE_UDP |
-	       AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_TXCOE_CTL, 1, 1, tmp);
+		napi_disable(napi);
+		smp_mb__before_atomic();
+		set_bit(AX88179_ENABLE, &axdev->flags);
+		smp_mb__after_atomic();
+
+		if (netif_carrier_ok(netdev)) {
+			if (axdev->link) {
+				ax_link_reset(axdev);
+				ax_start_rx(axdev);
+			} else {
+				netif_carrier_off(netdev);
+				ax_disable(axdev);
+			}
+		}
+		
+		napi_enable(napi);
+		clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+		smp_mb__after_atomic();
+		if (!list_empty(&axdev->rx_done)) {
+			local_bh_disable();
+			napi_schedule(&axdev->napi);
+			local_bh_enable();
+		}
+		ax88179_write_cmd_nopm(axdev, AX_PHY_POLLING, 1, 0, 0, NULL);
+		usb_submit_urb(axdev->intr_urb, GFP_NOIO);
+	} else {
+		clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+		smp_mb__after_atomic();
+	}
 
-	/* Configure RX control register => start operation */
-	*tmp16 = AX_RX_CTL_DROPCRCERR | AX_RX_CTL_IPE | AX_RX_CTL_START |
-		 AX_RX_CTL_AP | AX_RX_CTL_AMALL | AX_RX_CTL_AB;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, tmp16);
-
-	*tmp = AX_MONITOR_MODE_PMETYPE | AX_MONITOR_MODE_PMEPOL |
-	       AX_MONITOR_MODE_RWMP;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MONITOR_MOD, 1, 1, tmp);
+	return 0;
+}
 
-	/* Configure default medium type => giga */
-	*tmp16 = AX_MEDIUM_RECEIVE_EN | AX_MEDIUM_TXFLOW_CTRLEN |
-		 AX_MEDIUM_RXFLOW_CTRLEN | AX_MEDIUM_FULL_DUPLEX |
-		 AX_MEDIUM_GIGAMODE;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, tmp16);
-
-	ax88179_led_setting(dev);
-
-	ax179_data->eee_enabled = 0;
-	ax179_data->eee_active = 0;
-
-	ax88179_disable_eee(dev);
-
-	ax88179_ethtool_get_eee(dev, &eee_data);
-	eee_data.advertised = 0;
-	ax88179_ethtool_set_eee(dev, &eee_data);
+static int ax_system_suspend(struct ax_device *axdev)
+{
+	struct net_device *netdev = axdev->netdev;
+	int ret = 0;
 
-	/* Restart autoneg */
-	mii_nway_restart(&dev->mii);
+	netif_device_detach(netdev);
 
-	usbnet_link_change(dev, 0, 0);
+	if (netif_running(netdev) && test_bit(AX88179_ENABLE, &axdev->flags)) {
+		struct napi_struct *napi = &axdev->napi;
+		u16 reg16;
+
+		smp_mb__before_atomic();
+		clear_bit(AX88179_ENABLE, &axdev->flags);
+		smp_mb__after_atomic();
+		usb_kill_urb(axdev->intr_urb);
+		ax_disable(axdev);
+		
+		/* Disable RX path */
+		ax88179_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
+				      2, 2, &reg16, 1);
+		reg16 &= ~AX_MEDIUM_RECEIVE_EN;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC,  AX_MEDIUM_STATUS_MODE,
+				       2, 2, &reg16);
+
+		ax88179_read_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+				      2, 2, &reg16, 1);
+		reg16 |= AX_PHYPWR_RSTCTL_IPRL;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_PHYPWR_RSTCTL,
+				       2, 2, &reg16);
+
+		reg16 = AX_RX_CTL_STOP;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL, 2, 2, &reg16);
+
+		napi_disable(napi);
+		cancel_delayed_work_sync(&axdev->schedule);
+		napi_enable(napi);
+	}
 
-	return 0;
+	return ret;
 }
 
-static int ax88179_stop(struct usbnet *dev)
+static int ax_runtime_suspend(struct ax_device *axdev)
 {
-	u16 tmp16;
+	struct net_device *netdev = axdev->netdev;
+	int ret = 0;
 
-	ax88179_read_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			 2, 2, &tmp16);
-	tmp16 &= ~AX_MEDIUM_RECEIVE_EN;
-	ax88179_write_cmd(dev, AX_ACCESS_MAC, AX_MEDIUM_STATUS_MODE,
-			  2, 2, &tmp16);
+	set_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+	smp_mb__after_atomic();
 
-	return 0;
+	if (netif_running(netdev) && test_bit(AX88179_ENABLE, &axdev->flags)) {
+		u16 reg16;
+
+		if (netif_carrier_ok(netdev)) {
+			ax88179_read_cmd_nopm(axdev, AX_ACCESS_MAC,
+					      AX_RX_FREE_BUF_LOW, 
+					      2, 2, &reg16, 1);
+			if (reg16 != 0x067F) {
+				ret = -EBUSY;
+				goto out1;
+			}
+		}
+
+		smp_mb__before_atomic();
+		clear_bit(AX88179_ENABLE, &axdev->flags);
+		smp_mb__after_atomic();
+		usb_kill_urb(axdev->intr_urb);
+
+		if (netif_carrier_ok(netdev)) {
+			struct napi_struct *napi = &axdev->napi;
+
+			napi_disable(napi);
+			ax_stop_rx(axdev);
+			napi_enable(napi);
+		}
+
+		/* Disable RX path */
+		ax88179_read_cmd_nopm(axdev, AX_ACCESS_MAC,
+				      AX_MEDIUM_STATUS_MODE, 2, 2, &reg16, 1);
+		reg16 &= ~AX_MEDIUM_RECEIVE_EN;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC,
+				       AX_MEDIUM_STATUS_MODE, 2, 2, &reg16);
+
+		/* Configure RX control register => stop operation */
+		reg16 = AX_RX_CTL_STOP;
+		ax88179_write_cmd_nopm(axdev, AX_ACCESS_MAC, AX_RX_CTL,
+				       2, 2, &reg16);
+	}
+
+out1:
+	return ret;
 }
 
-static const struct driver_info ax88179_info = {
-	.description = "ASIX AX88179 USB 3.0 Gigabit Ethernet",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+static int ax88179_suspend(struct usb_interface *intf, pm_message_t message)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	int ret;
+	
+	mutex_lock(&axdev->control);
 
-static const struct driver_info ax88178a_info = {
-	.description = "ASIX AX88178A USB 2.0 Gigabit Ethernet",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+	if (PMSG_IS_AUTO(message))		
+		ret = ax_runtime_suspend(axdev);
+	else
+		ret = ax_system_suspend(axdev);
 
-static const struct driver_info cypress_GX3_info = {
-	.description = "Cypress GX3 SuperSpeed to Gigabit Ethernet Controller",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+	mutex_unlock(&axdev->control);
 
-static const struct driver_info dlink_dub1312_info = {
-	.description = "D-Link DUB-1312 USB 3.0 to Gigabit Ethernet Adapter",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+	return ret;
+}
 
-static const struct driver_info sitecom_info = {
-	.description = "Sitecom USB 3.0 to Gigabit Adapter",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+static int ax88179_resume(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);
+	int ret;
 
-static const struct driver_info samsung_info = {
-	.description = "Samsung USB Ethernet Adapter",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+	mutex_lock(&axdev->control);
 
-static const struct driver_info lenovo_info = {
-	.description = "Lenovo OneLinkDock Gigabit LAN",
-	.bind = ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset = ax88179_reset,
-	.stop = ax88179_stop,
-	.flags = FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+	if (test_bit(AX_SELECTIVE_SUSPEND, &axdev->flags))
+		ret = ax_runtime_resume(axdev);
+	else
+		ret = ax_system_resume(axdev);
 
-static const struct driver_info belkin_info = {
-	.description = "Belkin USB Ethernet Adapter",
-	.bind	= ax88179_bind,
-	.unbind = ax88179_unbind,
-	.status = ax88179_status,
-	.link_reset = ax88179_link_reset,
-	.reset	= ax88179_reset,
-	.flags	= FLAG_ETHER | FLAG_FRAMING_AX,
-	.rx_fixup = ax88179_rx_fixup,
-	.tx_fixup = ax88179_tx_fixup,
-};
+	mutex_unlock(&axdev->control);
+	return ret;
+}
+
+static int ax88179_reset_resume(struct usb_interface *intf)
+{
+	struct ax_device *axdev = usb_get_intfdata(intf);	
+
+	clear_bit(AX_SELECTIVE_SUSPEND, &axdev->flags);
+	mutex_lock(&axdev->control);
+	ax_hw_init(axdev);
+	mutex_unlock(&axdev->control);
+
+	return 0;
+}
 
-static const struct usb_device_id products[] = {
+/* table of devices that work with this driver */
+static const struct usb_device_id ax88179_table[] = {
 {
-	/* ASIX AX88179 10/100/1000 */
 	USB_DEVICE(0x0b95, 0x1790),
-	.driver_info = (unsigned long)&ax88179_info,
-}, {
-	/* ASIX AX88178A 10/100/1000 */
+},
+{
 	USB_DEVICE(0x0b95, 0x178a),
-	.driver_info = (unsigned long)&ax88178a_info,
-}, {
-	/* Cypress GX3 SuperSpeed to Gigabit Ethernet Bridge Controller */
-	USB_DEVICE(0x04b4, 0x3610),
-	.driver_info = (unsigned long)&cypress_GX3_info,
-}, {
-	/* D-Link DUB-1312 USB 3.0 to Gigabit Ethernet Adapter */
-	USB_DEVICE(0x2001, 0x4a00),
-	.driver_info = (unsigned long)&dlink_dub1312_info,
-}, {
-	/* Sitecom USB 3.0 to Gigabit Adapter */
-	USB_DEVICE(0x0df6, 0x0072),
-	.driver_info = (unsigned long)&sitecom_info,
-}, {
-	/* Samsung USB Ethernet Adapter */
-	USB_DEVICE(0x04e8, 0xa100),
-	.driver_info = (unsigned long)&samsung_info,
-}, {
-	/* Lenovo OneLinkDock Gigabit LAN */
-	USB_DEVICE(0x17ef, 0x304b),
-	.driver_info = (unsigned long)&lenovo_info,
-}, {
-	/* Belkin B2B128 USB 3.0 Hub + Gigabit Ethernet Adapter */
-	USB_DEVICE(0x050d, 0x0128),
-	.driver_info = (unsigned long)&belkin_info,
 },
-	{ },
+	{},	/* END */
 };
-MODULE_DEVICE_TABLE(usb, products);
 
-static struct usb_driver ax88179_178a_driver = {
-	.name =		"ax88179_178a",
-	.id_table =	products,
-	.probe =	usbnet_probe,
+MODULE_DEVICE_TABLE(usb, ax88179_table);
+
+static struct usb_driver ax88179_driver = {
+	.name =		MODULENAME,
+	.id_table =	ax88179_table,
+	.probe =	ax88179_probe,
+	.disconnect =	ax88179_disconnect,
 	.suspend =	ax88179_suspend,
 	.resume =	ax88179_resume,
-	.reset_resume =	ax88179_resume,
-	.disconnect =	usbnet_disconnect,
+	.reset_resume =	ax88179_reset_resume,
+	.pre_reset =	ax88179_pre_reset,
+	.post_reset =	ax88179_post_reset,
 	.supports_autosuspend = 1,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,5,0)
 	.disable_hub_initiated_lpm = 1,
+#endif
 };
-
-module_usb_driver(ax88179_178a_driver);
-
-MODULE_DESCRIPTION("ASIX AX88179/178A based USB 3.0/2.0 Gigabit Ethernet Devices");
-MODULE_LICENSE("GPL");
+module_usb_driver(ax88179_driver);
+/* End of Driver operations */
diff -Naur linux.org/drivers/net/usb/ax88179_178a.h linux.new/drivers/net/usb/ax88179_178a.h
--- linux.org/drivers/net/usb/ax88179_178a.h	1970-01-01 01:00:00.000000000 +0100
+++ linux.new/drivers/net/usb/ax88179_178a.h	2020-02-05 13:33:33.687025143 +0100
@@ -0,0 +1,435 @@
+#ifndef	__LINUX_USBNET_ASIX_H
+#define	__LINUX_USBNET_ASIX_H
+
+#ifndef smp_mb__before_atomic
+#define smp_mb__before_atomic()			smp_mb()
+#endif
+
+#ifndef smp_mb__after_atomic
+#define smp_mb__after_atomic()			smp_mb()
+#endif
+#define napi_alloc_skb(napi, length)		netdev_alloc_skb_ip_align(netdev,length)
+#define napi_complete_done(n, d)		napi_complete(n)
+
+/* 
+ *Version Information
+ */
+#define DRIVER_VERSION		"v2.0.0"
+#define DRIVER_AUTHOR		"ASIX"
+#define DRIVER_DESC		"ASIX AX88179_178A based USB 2.0/3.0 Gigabit \
+				 Ethernet Devices"
+#define MODULENAME		"ax88179_178a"
+
+#define AX88179_MAX_TX		4
+#define AX88179_MAX_RX		10
+#define AX88179_BUF_RX_SIZE	(48 * 1024)
+#define AX88179_BUF_TX_SIZE	(16 * 1024)
+#define INTBUFSIZE		8
+#define TX_ALIGN		4
+#define RX_ALIGN		8
+
+#define AX_TX_HEADER_LEN	8
+
+#define AX88179_TX_TIMEOUT	(5 * HZ)
+#define AX88179_NAPI_WEIGHT	64
+
+/*
+ * USB Command
+ */
+#define AX88179_REQT_READ	USB_DIR_OUT | USB_TYPE_VENDOR | USB_RECIP_DEVICE
+#define AX88179_REQT_WRITE	USB_DIR_IN | USB_TYPE_VENDOR | USB_RECIP_DEVICE
+
+#define AX88179_PHY_ID			0x03
+#define AX_MCAST_FILTER_SIZE		8
+#define AX_MAX_MCAST			64
+#define AX_EEPROM_LEN			0x40
+#define AX_RX_CHECKSUM			1
+#define AX_TX_CHECKSUM			2
+
+#define AX_BULKIN_24K			0x18;	/* 24k */
+
+#define AX_ACCESS_MAC			0x01
+#define AX_ACCESS_PHY			0x02
+#define AX_ACCESS_WAKEUP		0x03
+#define AX_ACCESS_EEPROM		0x04
+#define AX_ACCESS_EFUSE			0x05
+#define AX_RELOAD_EEPROM_EFUSE		0x06
+#define AX_WRITE_EFUSE_EN		0x09
+#define AX_WRITE_EFUSE_DIS		0x0A
+#define AX_ACCESS_MFAB			0x10
+#define AX_PHY_POLLING			0x90
+
+#define PHYSICAL_LINK_STATUS		0x02
+	#define	AX_USB_SS		0x04
+	#define	AX_USB_HS		0x02
+	#define	AX_USB_FS		0x01
+
+#define GENERAL_STATUS			0x03
+/* Check AX88179 version. UA1:Bit2 = 0,  UA2:Bit2 = 1 */
+	#define	AX_SECLD		0x04
+
+
+
+#define AX_SROM_ADDR			0x07
+#define AX_SROM_CMD			0x0a
+	#define EEP_RD			0x04	/* EEprom read command */
+	#define EEP_WR			0x08	/* EEprom write command */
+	#define EEP_BUSY		0x10	/* EEprom access module busy */
+
+
+#define AX_SROM_DATA_LOW		0x08
+#define AX_SROM_DATA_HIGH		0x09
+
+#define AX_RX_CTL			0x0b
+	#define AX_RX_CTL_DROPCRCERR		0x0100 /* Drop CRC error packet */
+	#define AX_RX_CTL_IPE			0x0200 /* Enable IP header in receive buffer aligned on 32-bit aligment */
+	#define AX_RX_CTL_TXPADCRC		0x0400 /* checksum value in rx header 3 */
+	#define AX_RX_CTL_START			0x0080 /* Ethernet MAC start */
+	#define AX_RX_CTL_AP			0x0020 /* Accept physcial address from Multicast array */
+	#define AX_RX_CTL_AM			0x0010 /* Accetp Brocadcast frames*/
+	#define AX_RX_CTL_AB			0x0008 /* HW auto-added 8-bytes data when meet USB bulk in transfer boundary (1024/512/64)*/
+	#define AX_RX_CTL_HA8B			0x0004
+	#define AX_RX_CTL_AMALL			0x0002 /* Accetp all multicast frames */
+	#define AX_RX_CTL_PRO			0x0001 /* Promiscuous Mode */
+	#define AX_RX_CTL_STOP			0x0000 /* Stop MAC */
+
+#define AX_NODE_ID			0x10
+#define AX_MULTI_FILTER_ARRY		0x16
+
+#define AX_MEDIUM_STATUS_MODE			0x22
+	#define AX_MEDIUM_GIGAMODE	0x01
+	#define AX_MEDIUM_FULL_DUPLEX	0x02
+	#define AX_MEDIUM_RXFLOW_CTRLEN	0x10
+	#define AX_MEDIUM_TXFLOW_CTRLEN	0x20
+	#define AX_MEDIUM_RECEIVE_EN	0x100
+	#define AX_MEDIUM_PS		0x200
+	#define AX_MEDIUM_JUMBO_EN	0x8040
+
+#define AX_MONITOR_MODE			0x24
+	#define AX_MONITOR_MODE_RWLC		0x02
+	#define AX_MONITOR_MODE_RWMP		0x04
+	#define AX_MONITOR_MODE_RWWF		0x08
+	#define AX_MONITOR_MODE_RW_FLAG		0x10
+	#define AX_MONITOR_MODE_PMEPOL		0x20
+	#define AX_MONITOR_MODE_PMETYPE		0x40
+
+#define AX_GPIO_CTRL			0x25
+	#define AX_GPIO_CTRL_GPIO3EN		0x80
+	#define AX_GPIO_CTRL_GPIO2EN		0x40
+	#define AX_GPIO_CTRL_GPIO1EN		0x20
+
+#define AX_PHYPWR_RSTCTL		0x26
+	#define AX_PHYPWR_RSTCTL_BZ		0x0010
+	#define AX_PHYPWR_RSTCTL_IPRL		0x0020
+	#define AX_PHYPWR_RSTCTL_AUTODETACH	0x1000
+
+#define AX_RX_BULKIN_QCTRL		0x2e
+	#define AX_RX_BULKIN_QCTRL_TIME		0x01
+	#define AX_RX_BULKIN_QCTRL_IFG		0x02
+	#define AX_RX_BULKIN_QCTRL_SIZE		0x04
+
+#define AX_RX_BULKIN_QTIMR_LOW		0x2f
+#define AX_RX_BULKIN_QTIMR_HIGH			0x30
+#define AX_RX_BULKIN_QSIZE			0x31
+#define AX_RX_BULKIN_QIFG			0x32
+
+#define AX_CLK_SELECT			0x33
+	#define AX_CLK_SELECT_BCS		0x01
+	#define AX_CLK_SELECT_ACS		0x02
+	#define AX_CLK_SELECT_ACSREQ		0x10
+	#define AX_CLK_SELECT_ULR		0x08
+
+#define AX_RXCOE_CTL			0x34
+	#define AX_RXCOE_IP			0x01
+	#define AX_RXCOE_TCP			0x02
+	#define AX_RXCOE_UDP			0x04
+	#define AX_RXCOE_ICMP			0x08
+	#define AX_RXCOE_IGMP			0x10
+	#define AX_RXCOE_TCPV6			0x20
+	#define AX_RXCOE_UDPV6			0x40
+	#define AX_RXCOE_ICMV6			0x80
+
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+	#define AX_RXCOE_DEF_CSUM	(AX_RXCOE_IP	| AX_RXCOE_TCP  | \
+					 AX_RXCOE_UDP	| AX_RXCOE_ICMV6 | \
+					 AX_RXCOE_TCPV6	| AX_RXCOE_UDPV6)
+#else
+	#define AX_RXCOE_DEF_CSUM	(AX_RXCOE_IP	| AX_RXCOE_TCP | \
+					 AX_RXCOE_UDP)
+#endif
+
+#define AX_TXCOE_CTL			0x35
+	#define AX_TXCOE_IP			0x01
+	#define AX_TXCOE_TCP			0x02
+	#define AX_TXCOE_UDP			0x04
+	#define AX_TXCOE_ICMP			0x08
+	#define AX_TXCOE_IGMP			0x10
+	#define AX_TXCOE_TCPV6			0x20
+	#define AX_TXCOE_UDPV6			0x40
+	#define AX_TXCOE_ICMV6			0x80
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2, 6, 22)
+	#define AX_TXCOE_DEF_CSUM	(AX_TXCOE_TCP   | AX_TXCOE_UDP | \
+					 AX_TXCOE_TCPV6 | AX_TXCOE_UDPV6)
+#else
+	#define AX_TXCOE_DEF_CSUM	(AX_TXCOE_TCP	| AX_TXCOE_UDP)
+#endif
+
+#define AX_PAUSE_WATERLVL_HIGH		0x54
+#define AX_PAUSE_WATERLVL_LOW		0x55
+
+#define AX_RX_FREE_BUF_LOW		0x57
+
+
+#define AX_EEP_EFUSE_CORRECT		0x00
+#define AX88179_EEPROM_MAGIC			0x17900b95
+
+/*
+ *GMII register definitions
+ */
+#define GMII_PHY_CONTROL			0x00	/* control reg */
+	/* Bit definitions: GMII Control */
+	#define GMII_CONTROL_RESET		0x8000	/* reset bit in control reg */
+	#define GMII_CONTROL_LOOPBACK		0x4000	/* loopback bit in control reg */
+	#define GMII_CONTROL_10MB		0x0000	/* 10 Mbit */
+	#define GMII_CONTROL_100MB		0x2000	/* 100Mbit */
+	#define GMII_CONTROL_1000MB		0x0040	/* 1000Mbit */
+	#define GMII_CONTROL_SPEED_BITS		0x2040	/* speed bit mask */
+	#define GMII_CONTROL_ENABLE_AUTO	0x1000	/* autonegotiate enable */
+	#define GMII_CONTROL_POWER_DOWN		0x0800
+	#define GMII_CONTROL_ISOLATE		0x0400	/* islolate bit */
+	#define GMII_CONTROL_START_AUTO		0x0200	/* restart autonegotiate */
+	#define GMII_CONTROL_FULL_DUPLEX	0x0100
+
+#define GMII_PHY_STATUS				0x01	/* status reg */
+	/* Bit definitions: GMII Status */
+	#define GMII_STATUS_100MB_MASK		0xE000	/* any of these indicate 100 Mbit */
+	#define GMII_STATUS_10MB_MASK		0x1800	/* either of these indicate 10 Mbit */
+	#define GMII_STATUS_AUTO_DONE		0x0020	/* auto negotiation complete */
+	#define GMII_STATUS_AUTO		0x0008	/* auto negotiation is available */
+	#define GMII_STATUS_LINK_UP		0x0004	/* link status bit */
+	#define GMII_STATUS_EXTENDED		0x0001	/* extended regs exist */
+	#define GMII_STATUS_100T4		0x8000	/* capable of 100BT4 */
+	#define GMII_STATUS_100TXFD		0x4000	/* capable of 100BTX full duplex */
+	#define GMII_STATUS_100TX		0x2000	/* capable of 100BTX */
+	#define GMII_STATUS_10TFD		0x1000	/* capable of 10BT full duplex */
+	#define GMII_STATUS_10T			0x0800	/* capable of 10BT */
+
+#define GMII_PHY_OUI				0x02	/* most of the OUI bits */
+#define GMII_PHY_MODEL				0x03	/* model/rev bits, and rest of OUI */
+#define GMII_PHY_ANAR				0x04	/* AN advertisement reg */
+	/* Bit definitions: Auto-Negotiation Advertisement */
+	#define GMII_ANAR_ASYM_PAUSE		0x0800	/* support asymetric pause */
+	#define GMII_ANAR_PAUSE			0x0400	/* support pause packets */
+	#define GMII_ANAR_100T4			0x0200	/* support 100BT4 */
+	#define GMII_ANAR_100TXFD		0x0100	/* support 100BTX full duplex */
+	#define GMII_ANAR_100TX			0x0080	/* support 100BTX half duplex */
+	#define GMII_ANAR_10TFD			0x0040	/* support 10BT full duplex */
+	#define GMII_ANAR_10T			0x0020	/* support 10BT half duplex */
+	#define GMII_SELECTOR_FIELD		0x001F	/* selector field. */
+
+#define GMII_PHY_ANLPAR				0x05	/* AN Link Partner */
+	/* Bit definitions: Auto-Negotiation Link Partner Ability */
+	#define GMII_ANLPAR_100T4		0x0200	/* support 100BT4 */
+	#define GMII_ANLPAR_100TXFD		0x0100	/* support 100BTX full duplex */
+	#define GMII_ANLPAR_100TX		0x0080	/* support 100BTX half duplex */
+	#define GMII_ANLPAR_10TFD		0x0040	/* support 10BT full duplex */
+	#define GMII_ANLPAR_10T			0x0020	/* support 10BT half duplex */
+	#define GMII_ANLPAR_PAUSE		0x0400	/* support pause packets */
+	#define GMII_ANLPAR_ASYM_PAUSE		0x0800	/* support asymetric pause */
+	#define GMII_ANLPAR_ACK			0x4000	/* means LCB was successfully rx'd */
+	#define GMII_SELECTOR_8023		0x0001;
+
+#define GMII_PHY_ANER				0x06		/* AN expansion reg */
+#define GMII_PHY_1000BT_CONTROL			0x09	/* control reg for 1000BT */
+#define GMII_PHY_1000BT_STATUS			0x0A	/* status reg for 1000BT */
+
+#define GMII_PHY_MACR				0x0D
+#define GMII_PHY_MAADR				0x0E
+
+#define GMII_PHY_PHYSR				0x11	/* PHY specific status register */
+	#define GMII_PHY_PHYSR_SMASK	0xc000
+	#define GMII_PHY_PHYSR_GIGA		0x8000
+	#define GMII_PHY_PHYSR_100		0x4000
+	#define GMII_PHY_PHYSR_FULL		0x2000
+	#define GMII_PHY_PHYSR_LINK		0x400
+
+/* Bit definitions: 1000BaseT AUX Control */
+#define GMII_1000_AUX_CTRL_MASTER_SLAVE		0x1000
+#define GMII_1000_AUX_CTRL_FD_CAPABLE		0x0200	/* full duplex capable */
+#define GMII_1000_AUX_CTRL_HD_CAPABLE		0x0100	/* half duplex capable */
+
+/* Bit definitions: 1000BaseT AUX Status */
+#define GMII_1000_AUX_STATUS_FD_CAPABLE		0x0800	/* full duplex capable */
+#define GMII_1000_AUX_STATUS_HD_CAPABLE		0x0400	/* half duplex capable */
+
+/* Cicada MII Registers */
+#define GMII_AUX_CTRL_STATUS			0x1C
+#define GMII_AUX_ANEG_CPLT			0x8000
+#define GMII_AUX_FDX				0x0020
+#define GMII_AUX_SPEED_1000			0x0010
+#define GMII_AUX_SPEED_100			0x0008
+
+#define GMII_LED_ACTIVE				0x1a
+	#define GMII_LED_ACTIVE_MASK		0xff8f
+	#define GMII_LED0_ACTIVE		(1 << 4)
+	#define GMII_LED1_ACTIVE		(1 << 5)
+	#define GMII_LED2_ACTIVE		(1 << 6)
+
+#define GMII_LED_LINK				0x1c
+	#define GMII_LED_LINK_MASK		0xf888
+	#define GMII_LED0_LINK_10		(1 << 0)
+	#define GMII_LED0_LINK_100		(1 << 1)
+	#define GMII_LED0_LINK_1000		(1 << 2)
+	#define GMII_LED1_LINK_10		(1 << 4)
+	#define GMII_LED1_LINK_100		(1 << 5)
+	#define GMII_LED1_LINK_1000		(1 << 6)
+	#define GMII_LED2_LINK_10		(1 << 8)
+	#define GMII_LED2_LINK_100		(1 << 9)
+	#define GMII_LED2_LINK_1000		(1 << 10)
+
+	#define	LED_VALID	(1 << 15) /* UA2 LED Setting */
+
+	#define	LED0_ACTIVE	(1 << 0)
+	#define	LED0_LINK_10	(1 << 1)
+	#define	LED0_LINK_100	(1 << 2)
+	#define	LED0_LINK_1000	(1 << 3)
+	#define	LED0_FD		(1 << 4)
+	#define LED0_USB3_MASK	0x001f
+
+	#define	LED1_ACTIVE	(1 << 5)
+	#define	LED1_LINK_10	(1 << 6)
+	#define	LED1_LINK_100	(1 << 7)
+	#define	LED1_LINK_1000	(1 << 8)
+	#define	LED1_FD		(1 << 9)
+	#define LED1_USB3_MASK	0x03e0
+
+	#define	LED2_ACTIVE	(1 << 10)
+	#define	LED2_LINK_1000	(1 << 13)
+	#define	LED2_LINK_100	(1 << 12)
+	#define	LED2_LINK_10	(1 << 11)
+	#define	LED2_FD		(1 << 14)
+	#define LED2_USB3_MASK	0x7c00
+
+#define GMII_PHYPAGE				0x1e
+
+#define GMII_PHY_PAGE_SELECT			0x1f
+	#define GMII_PHY_PAGE_SELECT_EXT	0x0007
+	#define GMII_PHY_PAGE_SELECT_PAGE0	0X0000
+	#define GMII_PHY_PAGE_SELECT_PAGE1	0X0001
+	#define GMII_PHY_PAGE_SELECT_PAGE2	0X0002
+	#define GMII_PHY_PAGE_SELECT_PAGE3	0X0003
+	#define GMII_PHY_PAGE_SELECT_PAGE4	0X0004
+	#define GMII_PHY_PAGE_SELECT_PAGE5	0X0005
+	#define GMII_PHY_PAGE_SELECT_PAGE6	0X0006
+
+enum ax88179_flags {
+	AX88179_UNPLUG = 0,
+	AX88179_ENABLE,
+	AX88179_LINK_CHG,
+	AX_SELECTIVE_SUSPEND,
+	AX_SCHEDULE_NAPI,
+};
+
+struct ax_device;
+
+struct rx_desc {
+	struct list_head list;
+	struct urb *urb;
+	struct ax_device *context;
+	void *buffer;
+	void *head;
+};
+
+struct tx_desc {
+	struct list_head list;
+	struct urb *urb;
+	struct ax_device *context;
+	void *buffer;
+	void *head;
+	u32 skb_num;
+	u32 skb_len;
+};
+
+struct ax_device {
+	unsigned long flags;
+	struct usb_device *udev;
+	struct usb_interface *intf;
+	struct net_device *netdev;
+
+	struct napi_struct napi;	
+	struct urb *intr_urb;
+	struct tx_desc tx_list[32];
+	struct rx_desc rx_list[32];
+	struct list_head rx_done, tx_free;
+	struct sk_buff_head tx_queue, rx_queue;
+	struct sk_buff_head tx_lso_done;
+	spinlock_t rx_lock, tx_lock;
+	struct delayed_work schedule, hw_phy_work;
+	struct mii_if_info mii;
+	struct mutex control;	/* use for hw setting */	
+
+	int intr_interval;
+	u32 saved_wolopts;
+	u32 msg_enable;
+	u32 tx_qlen;
+	u32 advertising;
+	u16 speed;
+	u8 *intr_buff;
+
+	u8 link;
+	u16 rxctl;
+	u8 m_filter[8];
+};
+
+
+struct skb_data {	/* skb->cb is one of these */
+	struct urb		*urb;
+	struct ax_device		*dev;
+	size_t			length;
+};
+
+struct ax_device_async_handle {
+  	struct usb_ctrlrequest *req;
+  	u8 m_filter[8];
+  	u16 rxctl;
+} __attribute__ ((packed));
+
+struct ax_device_int_data {
+	__le16 res1;
+#define AX_INT_PPLS_LINK	(1 << 0)
+#define AX_INT_SPLS_LINK	(1 << 1)
+#define AX_INT_CABOFF_UNPLUG	(1 << 7)
+	u8 link;
+	__le16 res2;
+	u8 status;
+	__le16 res3;
+} __attribute__ ((packed));
+
+#define AX_RXHDR_L4_ERR		(1 << 8)
+#define AX_RXHDR_L3_ERR		(1 << 9)
+
+#define AX_RXHDR_L4_TYPE_ICMP		2
+#define AX_RXHDR_L4_TYPE_IGMP		3
+#define AX_RXHDR_L4_TYPE_TCMPV6		5
+
+#define AX_RXHDR_L3_TYPE_IP		1
+#define AX_RXHDR_L3_TYPE_IPV6		2
+
+#define AX_RXHDR_L4_TYPE_MASK			0x1c
+#define AX_RXHDR_L4_TYPE_UDP			4
+#define AX_RXHDR_L4_TYPE_TCP			16
+#define AX_RXHDR_L3CSUM_ERR			2
+#define AX_RXHDR_L4CSUM_ERR			1
+#define AX_RXHDR_CRC_ERR			0x20000000
+#define AX_RXHDR_MII_ERR			0x40000000
+#define AX_RXHDR_DROP_ERR			0x80000000
+
+static struct {unsigned char ctrl, timer_l, timer_h, size, ifg; }
+AX88179_BULKIN_SIZE[] =	{
+	{7, 0x70, 0,	0x0C, 0x0f},
+	{7, 0x70, 0,	0x0C, 0x0f},
+	{7, 0x20, 3,	0x16, 0xff},
+	{7, 0xae, 7, 	0x18, 0xff},
+};
+
+#endif /* __LINUX_USBNET_ASIX_H */
