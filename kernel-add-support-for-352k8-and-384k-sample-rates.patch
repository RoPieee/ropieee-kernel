diff --color -Naur linux.org/arch/arm/boot/dts/overlays/dionaudio-loco-overlay.dts linux.new/arch/arm/boot/dts/overlays/dionaudio-loco-overlay.dts
--- linux.org/arch/arm/boot/dts/overlays/dionaudio-loco-overlay.dts	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/arch/arm/boot/dts/overlays/dionaudio-loco-overlay.dts	2020-07-20 13:45:56.444852628 +0200
@@ -24,6 +24,7 @@
 				#sound-dai-cells = <0>;
 				compatible = "ti,pcm5102a";
 				status = "okay";
+				pcm5102a,384k;
 			};
 		};
 	};
diff --color -Naur linux.org/arch/arm/boot/dts/overlays/hifiberry-dac-overlay.dts linux.new/arch/arm/boot/dts/overlays/hifiberry-dac-overlay.dts
--- linux.org/arch/arm/boot/dts/overlays/hifiberry-dac-overlay.dts	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/arch/arm/boot/dts/overlays/hifiberry-dac-overlay.dts	2020-07-20 13:45:27.296815914 +0200
@@ -15,7 +15,7 @@
 	fragment@1 {
 		target-path = "/";
 		__overlay__ {
-			pcm5102a-codec {
+			pcm5102a_codec: pcm5102a-codec {
 				#sound-dai-cells = <0>;
 				compatible = "ti,pcm5102a";
 				status = "okay";
@@ -31,4 +31,8 @@
 			status = "okay";
 		};
 	};
+
+	__overrides__ {
+		384k = <&pcm5102a_codec>,"pcm5102a,384k?";
+	};
 };
diff --color -Naur linux.org/arch/arm/boot/dts/overlays/README linux.new/arch/arm/boot/dts/overlays/README
--- linux.org/arch/arm/boot/dts/overlays/README	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/arch/arm/boot/dts/overlays/README	2020-07-20 13:45:27.296815914 +0200
@@ -951,8 +951,9 @@
 
 Name:   hifiberry-dac
 Info:   Configures the HifiBerry DAC audio card
-Load:   dtoverlay=hifiberry-dac
-Params: <None>
+Load:   dtoverlay=hifiberry-dac,<param>
+Params: 384k                    Instructs the pcm5102a codec driver to support
+                                352k8 and 384k sample rates.
 
 
 Name:   hifiberry-dacplus
diff --color -Naur linux.org/include/sound/pcm.h linux.new/include/sound/pcm.h
--- linux.org/include/sound/pcm.h	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/include/sound/pcm.h	2020-07-20 13:57:28.278723973 +0200
@@ -131,6 +131,8 @@
 #define SNDRV_PCM_RATE_96000		(1<<10)		/* 96000Hz */
 #define SNDRV_PCM_RATE_176400		(1<<11)		/* 176400Hz */
 #define SNDRV_PCM_RATE_192000		(1<<12)		/* 192000Hz */
+#define SNDRV_PCM_RATE_352800		(1<<13)		/* 352800Hz */
+#define SNDRV_PCM_RATE_384000		(1<<14)		/* 384000Hz */
 
 #define SNDRV_PCM_RATE_CONTINUOUS	(1<<30)		/* continuous range */
 #define SNDRV_PCM_RATE_KNOT		(1<<31)		/* supports more non-continuos rates */
@@ -143,6 +145,9 @@
 					 SNDRV_PCM_RATE_88200|SNDRV_PCM_RATE_96000)
 #define SNDRV_PCM_RATE_8000_192000	(SNDRV_PCM_RATE_8000_96000|SNDRV_PCM_RATE_176400|\
 					 SNDRV_PCM_RATE_192000)
+#define SNDRV_PCM_RATE_8000_384000	(SNDRV_PCM_RATE_8000_192000|SNDRV_PCM_RATE_352800|\
+					 SNDRV_PCM_RATE_384000)
+
 #define _SNDRV_PCM_FMTBIT(fmt)		(1ULL << (__force int)SNDRV_PCM_FORMAT_##fmt)
 #define SNDRV_PCM_FMTBIT_S8		_SNDRV_PCM_FMTBIT(S8)
 #define SNDRV_PCM_FMTBIT_U8		_SNDRV_PCM_FMTBIT(U8)
diff --color -Naur linux.org/sound/core/pcm_native.c linux.new/sound/core/pcm_native.c
--- linux.org/sound/core/pcm_native.c	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/sound/core/pcm_native.c	2020-07-20 13:58:57.031835763 +0200
@@ -2144,13 +2144,13 @@
 	return snd_interval_refine(hw_param_interval(params, rule->var), &t);
 }
 
-#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_192000 != 1 << 12
+#if SNDRV_PCM_RATE_5512 != 1 << 0 || SNDRV_PCM_RATE_384000 != 1 << 14
 #error "Change this table"
 #endif
 
 static const unsigned int rates[] = {
 	5512, 8000, 11025, 16000, 22050, 32000, 44100,
-	48000, 64000, 88200, 96000, 176400, 192000
+	48000, 64000, 88200, 96000, 176400, 192000, 352800, 384000
 };
 
 const struct snd_pcm_hw_constraint_list snd_pcm_known_rates = {
diff --color -Naur linux.org/sound/soc/bcm/hifiberry_dacplus.c linux.new/sound/soc/bcm/hifiberry_dacplus.c
--- linux.org/sound/soc/bcm/hifiberry_dacplus.c	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/sound/soc/bcm/hifiberry_dacplus.c	2020-07-20 13:46:13.060873557 +0200
@@ -146,7 +146,7 @@
 static int snd_rpi_hifiberry_dacplus_init(struct snd_soc_pcm_runtime *rtd)
 {
 	struct snd_soc_component *component = rtd->codec_dai->component;
-	struct pcm512x_priv *priv;
+	struct pcm512x_priv *priv = snd_soc_component_get_drvdata(component);
 
 	if (slave)
 		snd_rpi_hifiberry_is_dacpro = false;
@@ -165,8 +165,16 @@
 		snd_soc_component_update_bits(component, PCM512x_BCLK_LRCLK_CFG, 0x31, 0x11);
 		snd_soc_component_update_bits(component, PCM512x_MASTER_MODE, 0x03, 0x03);
 		snd_soc_component_update_bits(component, PCM512x_MASTER_CLKDIV_2, 0x7f, 63);
+
+		/*
+		 * Default sclk to CLK_48EN_RATE, otherwise codec
+		 *  pcm512x_dai_startup_master method could call
+		 *  snd_pcm_hw_constraint_ratnums using CLK_44EN/64
+		 *  which will mask 384k sample rate.
+		 */
+		if (!IS_ERR(priv->sclk))
+			clk_set_rate(priv->sclk, CLK_48EN_RATE);
 	} else {
-		priv = snd_soc_component_get_drvdata(component);
 		priv->sclk = ERR_PTR(-ENOENT);
 	}
 
@@ -268,6 +276,18 @@
 	struct snd_soc_component *component = rtd->codec_dai->component;
 
 	snd_soc_component_update_bits(component, PCM512x_GPIO_CONTROL_1, 0x08, 0x00);
+
+	if (snd_rpi_hifiberry_is_dacpro) {
+		struct pcm512x_priv *priv = snd_soc_component_get_drvdata(component);
+		/*
+		 * Default sclk to CLK_48EN_RATE, otherwise codec
+		 *  pcm512x_dai_startup_master method could call
+		 *  snd_pcm_hw_constraint_ratnums using CLK_44EN/64
+		 *  which will mask 384k sample rate.
+		 */
+		if (!IS_ERR(priv->sclk))
+			clk_set_rate(priv->sclk, CLK_48EN_RATE);
+	}
 }
 
 /* machine stream operations */
diff --color -Naur linux.org/sound/soc/codecs/pcm5102a.c linux.new/sound/soc/codecs/pcm5102a.c
--- linux.org/sound/soc/codecs/pcm5102a.c	2020-07-17 09:56:46.000000000 +0200
+++ linux.new/sound/soc/codecs/pcm5102a.c	2020-07-20 13:46:05.059863479 +0200
@@ -20,16 +20,74 @@
 
 #include <sound/soc.h>
 
+struct pcm5102a_priv {
+	bool rates_384k;
+};
+
+static const u32 pcm5102a_rates[] = {
+	8000, 16000, 32000, 44100, 48000, 88200, 96000, 176400, 192000,
+	352800, 384000,
+};
+
+static const struct snd_pcm_hw_constraint_list pcm5102a_constraint_rates = {
+	.count = ARRAY_SIZE(pcm5102a_rates),
+	.list = pcm5102a_rates,
+};
+
+static int pcm5102a_dai_startup(struct snd_pcm_substream *substream,
+	struct snd_soc_dai *dai)
+{
+	struct snd_soc_component *component = dai->component;
+	struct pcm5102a_priv *priv = snd_soc_component_get_drvdata(component);
+	int ret;
+
+	dev_dbg(component->dev, "%s: set rates (8k-384k) constraint\n", __func__);
+
+	ret = snd_pcm_hw_constraint_list(substream->runtime, 0,
+					 SNDRV_PCM_HW_PARAM_RATE,
+					 &pcm5102a_constraint_rates);
+	if (ret != 0) {
+		dev_err(component->dev, "%s: Failed to set rates constraint: %d\n",
+			__func__, ret);
+		return ret;
+	}
+
+	if (!priv->rates_384k) {
+		dev_info(component->dev,
+			 "%s: Limiting sample rate support to 192kHz MAX\n",
+			 __func__);
+
+		dev_dbg(component->dev, "%s: set minmax (8k/192k) constraint\n",
+			__func__);
+
+		ret = snd_pcm_hw_constraint_minmax(substream->runtime,
+						   SNDRV_PCM_HW_PARAM_RATE,
+						   8000, 192000);
+		if (ret < 0) {
+			dev_err(component->dev, "%s: Failed to set minmax "
+				"constraint: %d\n", __func__, ret);
+			return ret;
+		}
+	}
+
+	return 0;
+}
+
+static const struct snd_soc_dai_ops pcm5102a_dai_ops = {
+	.startup = pcm5102a_dai_startup,
+};
+
 static struct snd_soc_dai_driver pcm5102a_dai = {
 	.name = "pcm5102a-hifi",
 	.playback = {
 		.channels_min = 2,
 		.channels_max = 2,
-		.rates = SNDRV_PCM_RATE_8000_192000,
+		.rates = SNDRV_PCM_RATE_KNOT,
 		.formats = SNDRV_PCM_FMTBIT_S16_LE |
 			   SNDRV_PCM_FMTBIT_S24_LE |
 			   SNDRV_PCM_FMTBIT_S32_LE
 	},
+	.ops = &pcm5102a_dai_ops,
 };
 
 static struct snd_soc_component_driver soc_component_dev_pcm5102a = {
@@ -41,6 +99,20 @@
 
 static int pcm5102a_probe(struct platform_device *pdev)
 {
+	struct pcm5102a_priv *priv;
+
+	priv = devm_kzalloc(&pdev->dev, sizeof(*priv), GFP_KERNEL);
+	if (!priv)
+		return -ENOMEM;
+
+#ifdef CONFIG_OF
+	if (pdev->dev.of_node)
+		priv->rates_384k = of_property_read_bool(pdev->dev.of_node,
+							 "pcm5102a,384k");
+#endif
+
+	dev_set_drvdata(&pdev->dev, priv);
+
 	return devm_snd_soc_register_component(&pdev->dev, &soc_component_dev_pcm5102a,
 			&pcm5102a_dai, 1);
 }
